0
00:00:12,720 --> 00:00:15,210
哈喽大家晚上好

1
00:00:15,211 --> 00:00:16,620
然后我是温铭

2
00:00:16,621 --> 00:00:22,020
然后今天分享的题目是基于APACHE APISIX的全流量API网关

3
00:00:23,340 --> 00:00:23,580
嗯

4
00:00:23,581 --> 00:00:24,150
在这之前

5
00:00:24,151 --> 00:00:25,920
我先大概的介绍一下我自己

6
00:00:25,921 --> 00:00:28,500
然后我现在在一家创业公司

7
00:00:28,501 --> 00:00:30,600
我们是一个远程的

8
00:00:30,601 --> 00:00:35,040
这种基于开源项目去做这种商业化公司

9
00:00:35,041 --> 00:00:35,550
同时呢

10
00:00:35,551 --> 00:00:39,960
我也是APACHE顶级项目APISIX的PMC的主席

11
00:00:41,310 --> 00:00:42,060
在此之外呢

12
00:00:42,061 --> 00:00:45,330
我还是贡献过一些其他的一些开源项目

13
00:00:45,331 --> 00:00:46,290
比如说SKYWALKING

14
00:00:46,291 --> 00:00:47,010
SKYWALKING

15
00:00:47,011 --> 00:00:48,990
SKYWALKING的COMMITOR

16
00:00:48,991 --> 00:00:50,970
我在极客时间写一个专栏

17
00:00:50,971 --> 00:00:53,280
叫OPENRESTY从入门到实战

18
00:00:53,281 --> 00:00:57,030
最后抽奖也会抽我这个专栏

19
00:00:57,031 --> 00:01:00,600
然后送给今天的一些听众

20
00:01:00,601 --> 00:01:01,770
在创业之前呢

21
00:01:01,771 --> 00:01:04,440
我在360是做360的企业安全

22
00:01:04,441 --> 00:01:07,260
同时也是360开源委员会的发起人

23
00:01:08,490 --> 00:01:11,460
我们和腾讯的也会有一些像yousa

24
00:01:11,461 --> 00:01:13,260
就是腾讯同学

25
00:01:13,261 --> 00:01:15,960
我们和腾讯之间也会有一些很好一些互动

26
00:01:15,961 --> 00:01:18,120
比如我是腾讯的TAP

27
00:01:18,121 --> 00:01:21,330
也是tars基金会的TOC成员

28
00:01:21,331 --> 00:01:23,340
因为我之前是做安全的

29
00:01:23,341 --> 00:01:26,880
所以我有四十多个安全方面的一些专利

30
00:01:26,881 --> 00:01:30,510
我这边的其实大部分的时间都是在做服务端开发

31
00:01:30,511 --> 00:01:31,620
最近三年多了

32
00:01:31,621 --> 00:01:32,580
一直是全职

33
00:01:32,581 --> 00:01:34,260
在做开源项目

34
00:01:34,261 --> 00:01:35,790
对这是我大概的一个介绍

35
00:01:38,100 --> 00:01:41,100
首先介绍一下我所在的公司支流科技

36
00:01:41,101 --> 00:01:44,760
然后他其实是一个比较

37
00:01:44,761 --> 00:01:46,830
大部分时间都是在做开源的

38
00:01:46,831 --> 00:01:49,620
这样的一家公司是一个开源商业化的公司

39
00:01:49,621 --> 00:01:52,200
这样的公司能在国外其实会比较多

40
00:01:52,201 --> 00:01:56,610
比如说大家知道的像Kafka后面的Confluent等等这样的公司

41
00:01:56,611 --> 00:01:58,290
但是在国内其实还比较少

42
00:01:58,291 --> 00:02:02,490
国内大家知道的可能就是APACHE KYLKIN还有TIDB

43
00:02:02,491 --> 00:02:05,190
他们之类的这种已经做得比较大的

44
00:02:05,191 --> 00:02:06,330
这样开源商业公司

45
00:02:06,331 --> 00:02:14,430
但其实你现在也有越来越多的正在初创的开源商业公司其实会越来越多

46
00:02:14,431 --> 00:02:15,360
APISIX呢

47
00:02:15,361 --> 00:02:17,760
是中国唯一一个由初创公司贡献的APACHE顶级项目

48
00:02:17,761 --> 00:02:20,550
也是最快毕业的项目

49
00:02:20,551 --> 00:02:22,680
我们用了九个月的时间毕业

50
00:02:22,681 --> 00:02:26,340
同时支流科技是LINUX基金会的白银会员

51
00:02:26,341 --> 00:02:28,530
是TARS基金会的创始会员

52
00:02:28,600 --> 00:02:32,800
所以我们会有非常多的东西会贡献给开源社区

53
00:02:34,830 --> 00:02:35,580
OK

54
00:02:35,581 --> 00:02:39,690
然后今天的其实主要是分为以下几个方面

55
00:02:39,691 --> 00:02:40,140
首先呢

56
00:02:40,141 --> 00:02:44,550
我会大概的说一下云原生带来了哪些的机会

57
00:02:44,551 --> 00:02:47,640
对个人的一些机会对企业的一些机会

58
00:02:47,641 --> 00:02:49,230
因为我们是一个云原生的社区

59
00:02:49,231 --> 00:02:51,930
所以大家对于云原生应该都会比较的熟悉

60
00:02:51,931 --> 00:02:54,960
所以这块可能会快速的带过去

61
00:02:54,961 --> 00:02:59,160
第二个部分是微服务和API网关的一个演进

62
00:02:59,161 --> 00:03:02,280
为什么我们会需要微服务, API网关呢

63
00:03:02,281 --> 00:03:08,130
他也是一个存在很长时间的这样的一个产品

64
00:03:08,131 --> 00:03:09,630
为什么在云原生里面

65
00:03:09,631 --> 00:03:12,720
他会有一些新的这样的一些产品

66
00:03:12,721 --> 00:03:13,920
一些开源项目会出现

67
00:03:15,510 --> 00:03:16,500
那后面的几个部分

68
00:03:16,501 --> 00:03:18,870
我会大概的介绍一下APISIX

69
00:03:18,871 --> 00:03:22,380
是什么APISIX是怎么做的

70
00:03:22,381 --> 00:03:25,530
以及apisix可以帮大家做哪些事情

71
00:03:25,531 --> 00:03:26,370
最后是我们

72
00:03:26,371 --> 00:03:29,820
未来的这样的一些规划希望通过今天的分享了

73
00:03:29,821 --> 00:03:39,720
能够让大家对微服务api网关以及现在在接入层的这样的一些开源项目会有一个大概的认识

74
00:03:39,721 --> 00:03:44,700
以及后面这些项目大概是会朝哪个方向去发展

75
00:03:47,310 --> 00:03:50,940
首先是云原生带来的这样的一个机会

76
00:03:50,941 --> 00:03:53,820
云原生的可以说是最近几年

77
00:03:53,821 --> 00:04:02,610
而且可以肯定的是也是未来五到十年一个非常大的一个技术的一个颠覆

78
00:04:02,611 --> 00:04:07,530
它把传统的一些企业的技术架构等于在重写

79
00:04:07,531 --> 00:04:12,600
比如说我们经常会说K8S可能已经把操作系统颠覆了

80
00:04:12,601 --> 00:04:14,220
他是因为云原生新的操作系统

81
00:04:14,221 --> 00:04:19,770
所有的容器服务都是由他来编排和控制了原来的单体的

82
00:04:19,771 --> 00:04:21,000
我们叫做巨石的

83
00:04:21,001 --> 00:04:24,240
这样的一些应用和服务都在向微服务迁移

84
00:04:25,200 --> 00:04:25,830
同时呢

85
00:04:25,831 --> 00:04:27,870
以前我们会可能会服务

86
00:04:27,871 --> 00:04:28,950
是跑在裸金属

87
00:04:28,951 --> 00:04:30,570
或者是跑在虚拟机上的

88
00:04:30,571 --> 00:04:36,750
但是现在基本上大家都会跑在容器里面去做这种资源的隔离最后呢

89
00:04:36,751 --> 00:04:42,600
我们看到的就是用K8S管理起来的非常多轻量级的

90
00:04:42,601 --> 00:04:44,520
而且可以弹性伸缩的应用

91
00:04:45,600 --> 00:04:50,370
而且我们这些服务可以很灵活的去跑在公有云

92
00:04:50,371 --> 00:04:51,150
混合云

93
00:04:51,151 --> 00:04:53,430
私有云等等各种环境上面去

94
00:04:53,431 --> 00:04:55,830
可以很灵活地去扩展

95
00:04:55,831 --> 00:04:59,790
这就是云原生带给我们的一个新的一个世界

96
00:04:59,791 --> 00:05:00,150
所以说

97
00:05:00,151 --> 00:05:09,210
现在很多的技术包括从数据库从容器到我们熟悉的微服务网关等等

98
00:05:09,211 --> 00:05:15,480
这样一些东西都在被云原生的相关的开源项目所改变

99
00:05:15,481 --> 00:05:19,800
在以前的我们可以看得到很多的项目其实都是闭源的

100
00:05:19,801 --> 00:05:22,590
比如说我们经常知道的IOE

101
00:05:22,591 --> 00:05:22,860


102
00:05:24,060 --> 00:05:25,380
他们都是一个闭源的

103
00:05:25,381 --> 00:05:30,270
然后由商业公司来提供对应的软件和服务

104
00:05:30,271 --> 00:05:32,130
而且卖的非常的贵

105
00:05:32,131 --> 00:05:34,200
但是我们在云原生的这个

106
00:05:35,280 --> 00:05:38,370
我们看云原生的CNCF的全景图

107
00:05:38,371 --> 00:05:43,260
我们可以看到绝大部分都是全新的开源项目

108
00:05:44,340 --> 00:05:44,670
所以

109
00:05:44,671 --> 00:05:46,470
在云原生的世界里面的

110
00:05:46,471 --> 00:05:50,100
其实云原生和开源两个是紧密结合在一起

111
00:05:50,101 --> 00:05:53,910
如果没有很多的基于云原生的开源项目

112
00:05:53,911 --> 00:05:56,370
那么云原生也不会像现在一样

113
00:05:56,371 --> 00:05:57,570
落地的这么快

114
00:05:57,571 --> 00:05:59,160
大家接受的程度这么高

115
00:06:00,120 --> 00:06:00,900
所以呢

116
00:06:00,901 --> 00:06:04,050
这也其实带来了很多商业上的这样的一些机会

117
00:06:05,280 --> 00:06:07,620
恩我们举一个云原生

118
00:06:07,621 --> 00:06:09,750
这种例子就会比较多了

119
00:06:09,751 --> 00:06:10,680
大家都比较熟悉

120
00:06:10,681 --> 00:06:12,810
所以我这一块就不讲了

121
00:06:12,811 --> 00:06:14,700
然后对于企业的机会来说呢

122
00:06:14,701 --> 00:06:15,930
对于企业来说

123
00:06:15,931 --> 00:06:19,680
云原生其实是一个非常适合去超越对手的

124
00:06:19,681 --> 00:06:22,470
这样的一个技术上的一个机会

125
00:06:22,471 --> 00:06:24,540
比如说像招商银行

126
00:06:24,541 --> 00:06:29,700
他每年会投入收入的3.5%用于金融科技

127
00:06:29,701 --> 00:06:31,950
这个是它写在自己的年报里面

128
00:06:32,850 --> 00:06:33,510
对所以说

129
00:06:33,511 --> 00:06:36,510
越来越多的传统行业的公司

130
00:06:36,511 --> 00:06:38,370
我们觉得他们可能会比较传统

131
00:06:38,371 --> 00:06:40,860
不太愿意去接受新的技术

132
00:06:40,861 --> 00:06:48,780
但是你们可我们可以看到越来越多的金融的公司在转变成为科技类的公司

133
00:06:48,781 --> 00:06:51,570
甚至未来如果不成为科技公司

134
00:06:51,571 --> 00:06:55,830
他就这个公司可能就已经被他的竞争对手远远的甩在了身后

135
00:06:57,390 --> 00:06:57,660
那么

136
00:06:57,661 --> 00:07:02,670
我们怎样去抓住云原生的带来的这个很大的机会呢

137
00:07:02,671 --> 00:07:03,600
其实来说呢

138
00:07:03,601 --> 00:07:04,440
在我这边看来

139
00:07:04,441 --> 00:07:08,310
其实从API入手是一个比较好的一个方法

140
00:07:08,311 --> 00:07:09,570
为什么这么说呢

141
00:07:09,571 --> 00:07:11,310
我们来看一下

142
00:07:11,311 --> 00:07:14,310
我们现在提供给用户的所有的服务

143
00:07:14,311 --> 00:07:19,020
不管是你提供的是客户端的App的服务

144
00:07:19,021 --> 00:07:21,180
还是你提供的是2B的

145
00:07:21,181 --> 00:07:23,190
这种SAAS类的服务

146
00:07:23,191 --> 00:07:26,310
它用户真正去使用的其实都是Api

147
00:07:27,390 --> 00:07:29,640
透过你的手机的App

148
00:07:29,641 --> 00:07:34,740
透过你的浏览器或者是你的其他的IoT的设备等等

149
00:07:34,741 --> 00:07:42,510
所有的他最后和服务端交互都是通过Api的一种形式来去做的

150
00:07:42,511 --> 00:07:43,110
所以

151
00:07:43,111 --> 00:07:45,480
如果我们能在Api上去入手

152
00:07:45,481 --> 00:07:50,730
那么对用户的体验其实是最容易去得到这样的一个改造的

153
00:07:50,731 --> 00:07:54,570
比如说你原来是一个这种单体的服务

154
00:07:54,571 --> 00:07:57,330
那么我把它改造成微服务的架构

155
00:07:57,331 --> 00:08:01,110
用户就可以明显的感觉到在流量很大的时候

156
00:08:01,111 --> 00:08:03,930
他会发现原来经常会宕机的服务

157
00:08:04,860 --> 00:08:06,270
不会宕机了

158
00:08:06,271 --> 00:08:07,140
然后呢

159
00:08:07,141 --> 00:08:10,140
一些在高峰流量下会被冲垮了

160
00:08:10,141 --> 00:08:12,360
这样的服务他在很短的时间之内

161
00:08:12,361 --> 00:08:13,260
我刷两次页面

162
00:08:13,261 --> 00:08:17,220
他就用很方便的去扩容了

163
00:08:17,221 --> 00:08:17,880
所以说呢

164
00:08:17,881 --> 00:08:19,050
从API入手来说了

165
00:08:19,051 --> 00:08:21,240
对客户的体验会是一个非常好的

166
00:08:21,241 --> 00:08:25,290
这样的一个有非常直接的改善

167
00:08:25,291 --> 00:08:27,210
那么对于企业其实也是一样

168
00:08:28,440 --> 00:08:36,390
我把以前的这种昂贵的IOE的和闭源的软件用开源的用云原生的这种架构也换掉

169
00:08:36,391 --> 00:08:39,630
我会节省非常多的硬件的成本

170
00:08:39,631 --> 00:08:43,770
比如说我以前的服务器是我自己要自建机房

171
00:08:43,771 --> 00:08:45,420
买很多物理机

172
00:08:45,421 --> 00:08:47,250
然后把服务在上面

173
00:08:47,251 --> 00:08:48,330
那么现在OK

174
00:08:48,331 --> 00:08:54,150
我可以全部迁到公有云或者是混合云的这种架构

175
00:08:54,151 --> 00:08:55,860
那么我在流量很大的时候

176
00:08:55,861 --> 00:09:02,490
我就可以在公有云上很方便的去弹性的扩容和缩容会给予我非常多的成本

177
00:09:02,491 --> 00:09:06,180
那么这个其实也是和微服务API相关的

178
00:09:06,181 --> 00:09:07,980
所以从这个地方去入手了

179
00:09:07,981 --> 00:09:10,200
其实不仅是对客户的体验

180
00:09:10,201 --> 00:09:14,220
还是去节约你的硬件的成本都是一个比较好的一个选择

181
00:09:15,600 --> 00:09:21,090
然后我们再看一下微服务和API网关的一个演进

182
00:09:21,091 --> 00:09:22,020
而这个图呢

183
00:09:22,021 --> 00:09:24,240
是谷歌的搜索指数

184
00:09:25,170 --> 00:09:27,720
对于微服务这个关键字的搜索

185
00:09:27,721 --> 00:09:28,530
我们可以看到

186
00:09:28,531 --> 00:09:32,250
从14年和15年开始

187
00:09:32,251 --> 00:09:34,230
微服务这个关键字的搜索了

188
00:09:34,231 --> 00:09:39,150
就成了成为一个直线上升的这样的一个趋势

189
00:09:39,151 --> 00:09:42,240
这个和我们其实对于微服务的认知也是差不多的

190
00:09:42,241 --> 00:09:45,270
我们也大概是从14年15年的时候

191
00:09:45,271 --> 00:09:46,830
我给大家听说微服务

192
00:09:46,831 --> 00:09:48,420
而且并且去逐步的去落地

193
00:09:51,150 --> 00:09:52,920
额这个是一个例子

194
00:09:52,921 --> 00:09:55,980
他解释了什么是一个单体的架构

195
00:09:55,981 --> 00:09:56,730
在最左侧

196
00:09:56,731 --> 00:09:58,860
那是一个客户端的请求

197
00:09:58,861 --> 00:10:02,670
中间的是一个负载均衡的一个设备

198
00:10:02,671 --> 00:10:03,840
在最右侧呢

199
00:10:03,841 --> 00:10:05,970
我们可以可能是有两台服务器

200
00:10:05,971 --> 00:10:07,560
每台服务器上呢

201
00:10:07,561 --> 00:10:10,770
他都跑了三个不同的业务

202
00:10:10,771 --> 00:10:14,460
比如说查询用户的身份

203
00:10:14,461 --> 00:10:15,120
然后

204
00:10:16,020 --> 00:10:17,520
验证完身份之后呢

205
00:10:17,521 --> 00:10:18,750
去查他的订单

206
00:10:18,751 --> 00:10:19,380
最后呢

207
00:10:19,381 --> 00:10:20,790
去看他的收据

208
00:10:21,960 --> 00:10:23,970
这是一个串行的一个过程

209
00:10:23,971 --> 00:10:27,300
他们三个服务之间的都和数据库做一个交互

210
00:10:28,230 --> 00:10:29,370
这种的好处呢

211
00:10:29,371 --> 00:10:32,400
很明显就是我可以一个人

212
00:10:32,401 --> 00:10:35,010
或者是一是一个小团队

213
00:10:35,011 --> 00:10:36,780
就把这一套东西全写完了

214
00:10:36,781 --> 00:10:38,310
因为我查完数据库

215
00:10:38,311 --> 00:10:39,630
查完是用户身份

216
00:10:39,631 --> 00:10:42,600
然后再拿用户的ID去查订单

217
00:10:42,601 --> 00:10:45,030
在拿用户的ID去查他的收据

218
00:10:45,031 --> 00:10:46,950
我都是在查同一个数据库

219
00:10:46,951 --> 00:10:50,220
我都可以在同一个语言里面写完

220
00:10:50,221 --> 00:10:54,540
对我的这三个服务可以都在一个进程里面

221
00:10:54,541 --> 00:10:56,130
同一个语言就可以做完了

222
00:10:56,131 --> 00:10:56,940
可是比较快

223
00:10:58,680 --> 00:11:00,180
额这是单体的架构

224
00:11:01,080 --> 00:11:02,370
那么在微服务里面了

225
00:11:02,371 --> 00:11:03,900
我们就会对他进行拆分

226
00:11:05,100 --> 00:11:09,270
比如说我的用户的认证这个服务呢

227
00:11:09,271 --> 00:11:10,620
可能不是特别频繁

228
00:11:10,621 --> 00:11:12,810
因为用户认证一次之后呢

229
00:11:12,811 --> 00:11:16,950
他就一段时间之内就不再需要去验证他的身份了

230
00:11:16,951 --> 00:11:20,430
但是下订单的查他的历史的那种收据呢

231
00:11:20,431 --> 00:11:21,360
可能会比较多

232
00:11:21,361 --> 00:11:23,370
所以我们在微服务架构里面呢

233
00:11:23,371 --> 00:11:27,570
我们就可以把这些服务和数据库进行拆分

234
00:11:27,571 --> 00:11:29,730
并且放在不同的服务器上

235
00:11:29,731 --> 00:11:31,350
这样的好处是呢

236
00:11:31,351 --> 00:11:32,850
在一些流量比较大的时候

237
00:11:32,851 --> 00:11:36,270
比如说双十一用户去下单的时候

238
00:11:36,271 --> 00:11:41,550
那么其实我没有必要去扩容用户身份认证的这块的服务器

239
00:11:41,551 --> 00:11:46,080
但是我需要把下单的这块服务器扩容的很大

240
00:11:46,081 --> 00:11:50,940
那么这块我就可以直接把orders这个服务变成很多台服务器

241
00:11:50,941 --> 00:11:53,040
其他我都可以不用动

242
00:11:53,041 --> 00:11:57,360
我就可以实行一个最小的一个弹性伸缩

243
00:11:57,361 --> 00:12:01,680
而且我可以保证我很多的计算资源都放在下单上面

244
00:12:01,681 --> 00:12:05,100
我要保证我的一个资源的一个

245
00:12:05,101 --> 00:12:06,570
最合理的一个分配

246
00:12:06,571 --> 00:12:09,060
我保证我最重要的业务是不会挂掉了

247
00:12:10,950 --> 00:12:12,450
在这个里面

248
00:12:12,451 --> 00:12:13,410
所以说呢

249
00:12:13,411 --> 00:12:16,440
微服务会给我们带来非常多的一个好处

250
00:12:16,441 --> 00:12:20,280
最直接的就是弹性的伸缩并且呢

251
00:12:20,281 --> 00:12:23,820
当我们把这些服务拆散之后

252
00:12:23,821 --> 00:12:25,800
我的开发变得敏捷了

253
00:12:25,801 --> 00:12:28,350
比如说我之前要去上线

254
00:12:28,351 --> 00:12:34,650
一个我修改了一个用户登录过的这样的一个系统

255
00:12:34,651 --> 00:12:36,840
那么如果我这里修改错了

256
00:12:36,841 --> 00:12:39,660
那么其实我连带着后面的下单

257
00:12:39,661 --> 00:12:42,630
连带着后面的收据等等

258
00:12:42,631 --> 00:12:44,190
全都会出问题OK

259
00:12:44,191 --> 00:12:45,450
但是现在不一样

260
00:12:45,451 --> 00:12:48,000
我可以只更新我的这块东西

261
00:12:48,001 --> 00:12:49,980
我不用担心影响其他的逻辑

262
00:12:49,981 --> 00:12:53,670
因为我们的这些代码都是完全隔离开的

263
00:12:53,671 --> 00:12:56,160
会把故障率去往下降

264
00:12:56,161 --> 00:12:57,300
但是带来的劣势呢

265
00:12:57,301 --> 00:12:59,010
其实也会比较明显

266
00:12:59,011 --> 00:13:05,190
就是说在左侧的在这个图里面的每一个系统

267
00:13:05,191 --> 00:13:08,730
它都会有很多冗余的功能重复的功能

268
00:13:08,731 --> 00:13:15,420
比如说我要不要去在里面加一些可观测性的这样的一些功能

269
00:13:15,421 --> 00:13:18,240
我要不要去加一些这种

270
00:13:18,241 --> 00:13:23,400
apm的这种应用性能分析的东西再给我要不要加一些限流

271
00:13:23,401 --> 00:13:24,540
限速在里面

272
00:13:24,541 --> 00:13:26,010
这是每一个服务都需要加

273
00:13:27,270 --> 00:13:27,720
对吧

274
00:13:27,721 --> 00:13:28,860
每户都需要加

275
00:13:28,861 --> 00:13:29,520
而且呢

276
00:13:29,521 --> 00:13:30,600
带来另外一个问题

277
00:13:30,601 --> 00:13:36,780
就是说我的服务会拆的非常的散可能我会有几百个微服务

278
00:13:36,781 --> 00:13:38,550
很散的情况下

279
00:13:38,551 --> 00:13:41,940
我怎么去管理哪一个地方出了故障

280
00:13:41,941 --> 00:13:44,130
其实那就会是一个比较大的一个问题

281
00:13:46,620 --> 00:13:47,100
所以呢

282
00:13:47,101 --> 00:13:50,190
如果我们引入一个网关那个角色

283
00:13:50,191 --> 00:13:55,050
能够通过网关把下面的微服务给统一指挥和管理起来

284
00:13:55,051 --> 00:13:57,090
就像我们在乐队里面一样

285
00:13:57,091 --> 00:13:59,310
每一个服务都很重要

286
00:13:59,311 --> 00:13:59,850
但是呢

287
00:13:59,851 --> 00:14:01,740
我们学校要有一个指挥

288
00:14:01,741 --> 00:14:05,460
把他们能够统一一起对外提供这样的一个服务

289
00:14:06,540 --> 00:14:07,200
然后呢

290
00:14:07,201 --> 00:14:11,430
这个是加了网关之后的这样的一个整体的架构

291
00:14:12,840 --> 00:14:14,280
终端请求过来之后呢

292
00:14:14,281 --> 00:14:20,460
我们先会过API网关里面我们会去做一些身份的认证

293
00:14:20,461 --> 00:14:20,880
限流

294
00:14:20,881 --> 00:14:24,450
限速以及可观测性记录日志等等

295
00:14:24,451 --> 00:14:26,850
这些非常通用的功能

296
00:14:26,851 --> 00:14:27,690
这些功能呢

297
00:14:27,691 --> 00:14:29,730
和后面的业务都是无关的

298
00:14:29,731 --> 00:14:36,030
我们把这些和业务无关的功能统一的抽象出来放在API网关上然后呢

299
00:14:36,031 --> 00:14:40,230
并且在API网关上去增加一些路由的功能啊

300
00:14:40,231 --> 00:14:43,650
然后或者是一些请求的合并等等

301
00:14:43,651 --> 00:14:46,650
这样的一些功能

302
00:14:46,651 --> 00:14:48,390
那么有了这个东西之后呢

303
00:14:48,391 --> 00:14:52,200
其实我们的微服务管理起来就会更加的容易些

304
00:14:53,910 --> 00:14:58,530
比如说API网关可以提供API聚合的一个功能

305
00:14:58,531 --> 00:15:06,060
在传统的单体用里面的客户端传过来的就是一个customer的ID

306
00:15:06,061 --> 00:15:09,450
然后他需要获取这个customer的什么信息呢

307
00:15:09,451 --> 00:15:15,120
需要拿了他的名字是要拿他的地址需要拿到他的订单和他的收据

308
00:15:15,121 --> 00:15:17,250
以前在单体用里面

309
00:15:17,251 --> 00:15:22,260
customers、orders、invoices的因为三个都是在一台机器甚至同一个进程里面

310
00:15:22,261 --> 00:15:24,300
那么这个事情其实很好做

311
00:15:24,301 --> 00:15:29,790
我查一次数据库或者是查三个SQL语句就可以完成了

312
00:15:29,791 --> 00:15:31,050
但是在微服务里面的

313
00:15:31,051 --> 00:15:32,550
其实你不太好做

314
00:15:32,551 --> 00:15:35,790
因为他其实会查到三个不同的服务

315
00:15:36,810 --> 00:15:40,350
而且这三个不同的服务可能是两个连着三个不同的数据库

316
00:15:41,310 --> 00:15:42,240
每个服务呢

317
00:15:42,241 --> 00:15:45,750
只返回了原来单体应用里面API接口的一部分

318
00:15:45,751 --> 00:15:46,890
那么这个时候呢

319
00:15:46,891 --> 00:15:49,530
我们是让客户端做改造吗

320
00:15:49,531 --> 00:15:51,510
让客户端查三次上来

321
00:15:51,511 --> 00:15:54,690
还是说我API网关上能做一次聚合

322
00:15:54,691 --> 00:15:56,160
我的API网关

323
00:15:56,161 --> 00:15:59,460
从客户端看到的还是一个请求

324
00:15:59,461 --> 00:16:02,460
但是我在平台层面上发起三个请求

325
00:16:02,461 --> 00:16:04,350
一看我们身边还有三个请求

326
00:16:04,300 --> 00:16:07,800
然后在他们返回之后把他们聚合在一起

327
00:16:07,891 --> 00:16:09,240
那么这样子的话

328
00:16:09,241 --> 00:16:10,170
那对客户端来说

329
00:16:10,171 --> 00:16:13,680
他是不用做改造了这些事情呢

330
00:16:13,681 --> 00:16:14,610
微服务来说

331
00:16:14,611 --> 00:16:17,490
微服务不用动客户端也不用动

332
00:16:17,491 --> 00:16:23,010
所有的工作量都是在API网关上面做了一个API聚合的这样一个功能

333
00:16:23,011 --> 00:16:25,140
这是Api网关可以做的事情之一

334
00:16:27,000 --> 00:16:29,070
还有一个更常见的功能呢

335
00:16:29,071 --> 00:16:32,250
也是Api网关非常重要的一个角色

336
00:16:32,251 --> 00:16:33,390
就是灰度发布

337
00:16:34,470 --> 00:16:37,830
恩我们新上一个功能的时候呢

338
00:16:37,831 --> 00:16:39,660
比如说原来的版本是一点零

339
00:16:39,661 --> 00:16:41,430
然后我们现在想上一个小版本

340
00:16:41,431 --> 00:16:43,620
一点零点一这个时候呢

341
00:16:43,621 --> 00:16:49,530
我们希望能够把10%的流量嵌到这个新的版本上面去

342
00:16:49,531 --> 00:16:50,880
如果没有问题

343
00:16:50,881 --> 00:16:52,140
我在20%

344
00:16:52,141 --> 00:16:55,920
30%逐步的灰度的去做这样一个发布

345
00:16:55,921 --> 00:16:58,620
这是一个很正常的一个操作

346
00:16:58,621 --> 00:16:59,550
那么这个操作呢

347
00:16:59,551 --> 00:17:01,470
你如果不在网关层面做

348
00:17:01,471 --> 00:17:03,090
其实是比较困难的

349
00:17:04,290 --> 00:17:08,220
恩在网络层面上的我们可以做到什么样的颗粒度呢

350
00:17:08,221 --> 00:17:15,120
现在大部分网站我们都是可以从一些http的头里面去获取到一些信息

351
00:17:15,121 --> 00:17:18,060
比如说或者是你的IP地址

352
00:17:18,061 --> 00:17:22,290
比如说你的IP是通过你的IP是广东

353
00:17:22,291 --> 00:17:25,200
并且你的带带上来的

354
00:17:25,201 --> 00:17:28,260
你的customerID在一个数值范围之内

355
00:17:28,261 --> 00:17:30,270
我就把你扔到一个新版本里面去

356
00:17:31,470 --> 00:17:35,160
现在的网关大部分都可以做到这样的一个颗粒度

357
00:17:35,161 --> 00:17:36,420
那么在APISIX里面呢

358
00:17:36,421 --> 00:17:40,080
其实我们能够做到的颗粒度会更加的细一些

359
00:17:40,081 --> 00:17:43,260
除了常见的Http的头之外

360
00:17:44,370 --> 00:17:47,250
我们还支持所有NGINX的变量

361
00:17:47,251 --> 00:17:49,680
NGINX变量其实就包含的会比较多

362
00:17:49,681 --> 00:17:51,750
不仅包含了头的信息

363
00:17:51,751 --> 00:17:58,110
也还包含URI里面的各种参数以及你的IP地址等等

364
00:17:58,111 --> 00:17:59,040
除此之外呢

365
00:17:59,041 --> 00:18:03,300
APISIX还提供了一个扩展的一个能力

366
00:18:03,301 --> 00:18:03,930
也就是说

367
00:18:03,931 --> 00:18:07,950
如果上面这些东西都不满足于灰度发布的需求

368
00:18:07,951 --> 00:18:13,200
比如说你的灰度发布是要通过一个复杂的公式去计算的

369
00:18:13,201 --> 00:18:22,380
那么APISIX还可以让你自己写LUA代码去用户的请求体或者是请求参数里面去做一些运算

370
00:18:22,381 --> 00:18:24,060
最终算出来

371
00:18:24,061 --> 00:18:25,050
他要不要去

372
00:18:25,980 --> 00:18:27,390
调度到某一个服务什么去

373
00:18:30,390 --> 00:18:33,840
另外一个API网关常见的功能就是熔断

374
00:18:33,841 --> 00:18:38,640
比如说我的最终的一个这个invoice这个服务

375
00:18:38,641 --> 00:18:40,440
他有非常多的错误

376
00:18:40,441 --> 00:18:42,390
那么对于后续的情况来说

377
00:18:42,391 --> 00:18:45,090
我就没有必要再去过这个服务了

378
00:18:45,091 --> 00:18:46,890
因为他已经太多的错误了

379
00:18:46,891 --> 00:18:50,430
那么他可能是很多服务器挂掉了这个事

380
00:18:50,431 --> 00:18:52,140
我就没必要再给他压力了

381
00:18:52,141 --> 00:18:53,820
我反馈客户端请求的时候呢

382
00:18:53,821 --> 00:18:55,500
就可以把这段的数据给丢掉

383
00:18:58,170 --> 00:19:01,440
所以我们可以看到那API网关的传统功能

384
00:19:01,441 --> 00:19:05,850
其实主要就是在反向代理、负载均衡

385
00:19:05,851 --> 00:19:08,130
就是希望API的请求更安全

386
00:19:08,131 --> 00:19:09,360
更高效

387
00:19:09,361 --> 00:19:10,560
这是API的传统功能

388
00:19:10,561 --> 00:19:14,550
其实就是NGINX去做了这么多的事

389
00:19:16,260 --> 00:19:18,330
除了这些之外呢

390
00:19:18,331 --> 00:19:19,590
嗯

391
00:19:19,591 --> 00:19:19,740
嗯

392
00:19:19,741 --> 00:19:22,470
就是NGINX里面还有一些事情做得不是很好的

393
00:19:22,471 --> 00:19:28,680
比如说动态的上游动态的证书以及动态限流限速都是和动态相关的

394
00:19:28,681 --> 00:19:30,300
因为我们知道Nginx呢

395
00:19:30,301 --> 00:19:34,710
他是一个配置文件来驱动的一个Web服务器

396
00:19:35,910 --> 00:19:39,900
我们如果要修改上游或者是修改证书

397
00:19:39,901 --> 00:19:41,490
或者是去修改它的限流

398
00:19:41,491 --> 00:19:44,130
限速的值都是要先修改配置文件

399
00:19:44,131 --> 00:19:46,380
然后NGINX reload

400
00:19:46,381 --> 00:19:51,120
后面的请求才会去生效, 这样一种方式呢

401
00:19:51,121 --> 00:19:53,370
在请求流量不大的时候

402
00:19:53,371 --> 00:19:58,440
或者是说我的上游和证书变更不频繁的时候

403
00:19:58,441 --> 00:20:00,270
这种事这种方式是OK的

404
00:20:00,271 --> 00:20:01,170
没问题的

405
00:20:01,171 --> 00:20:03,900
这就和NGINX当时诞生的年代是有关系的

406
00:20:03,901 --> 00:20:05,310
当时流量并不大

407
00:20:05,311 --> 00:20:09,450
而且也不会像在容器和K8S里面

408
00:20:09,451 --> 00:20:11,550
我们会频繁的去变更时上游

409
00:20:12,600 --> 00:20:13,140
在NGINX

410
00:20:13,141 --> 00:20:16,170
那个时代里面这些东西是不会频繁变更的

411
00:20:16,171 --> 00:20:17,820
但是在云原生其实不一样

412
00:20:17,821 --> 00:20:19,740
我们会经常的去变更我们的上游

413
00:20:19,741 --> 00:20:25,830
因为我们的微服务会弹性的扩容缩容甚至每秒钟都在变化

414
00:20:27,540 --> 00:20:31,080
对NGINX是在这个时候就不太适合了

415
00:20:31,081 --> 00:20:33,570
还有一个就是主动和被动的健康检查服务

416
00:20:33,571 --> 00:20:34,170
熔断等等

417
00:20:34,171 --> 00:20:36,210
这些其实都是API网关的一些传统功能

418
00:20:37,410 --> 00:20:41,850
但是在云原生下面的我们会有一些更多的一些更新的要求

419
00:20:41,851 --> 00:20:43,560
首先是动态就像刚才提到的

420
00:20:43,561 --> 00:20:47,190
我们不希望去reload的服务

421
00:20:47,191 --> 00:20:52,140
因为reload服务会对终端的请求造成抖动

422
00:20:52,141 --> 00:20:55,830
而且频繁的reload的也会影响用户的体验

423
00:20:55,831 --> 00:20:57,150
因为我需要把连接断掉

424
00:20:58,230 --> 00:20:58,740
然后呢

425
00:20:58,741 --> 00:20:59,400
除此之外呢

426
00:20:59,401 --> 00:21:03,300
我们还希望他是一个无状态的网关

427
00:21:03,301 --> 00:21:11,310
因为我们网关本身也希望他能够随意的扩容和缩容对哦

428
00:21:11,311 --> 00:21:12,210
除此之外呢

429
00:21:12,211 --> 00:21:15,270
网关其实是一个非常重要的一个

430
00:21:15,271 --> 00:21:18,630
承上起下的这样的一个组件

431
00:21:18,631 --> 00:21:21,750
因为它等于说是一个看大门的

432
00:21:21,751 --> 00:21:23,520
对所有的流量都会通过他

433
00:21:23,521 --> 00:21:30,480
所以我们希望我们网关不仅能够很快速的去处理API流量

434
00:21:30,481 --> 00:21:35,550
而且也能够去对接尽可能多的第三方的服务

435
00:21:35,551 --> 00:21:36,540
第三方的服务呢

436
00:21:36,541 --> 00:21:39,360
不只包括了Prometheus、Skywalking

437
00:21:39,361 --> 00:21:46,890
这些可观测性的开源的这样的项目也包括一些和身份证相关的Oauth0、OKTA等等

438
00:21:46,891 --> 00:21:49,140
也包括一些生成认证的SAAS服务

439
00:21:49,141 --> 00:21:51,750
我们都希望能够很好的去对接

440
00:21:51,751 --> 00:21:55,320
如果你要对接这么多东西

441
00:21:55,321 --> 00:21:56,280
在NGINX下面

442
00:21:56,281 --> 00:21:57,720
其实你是没有办法去做了

443
00:21:57,721 --> 00:22:00,480
因为NGINX只能写C模块

444
00:22:00,481 --> 00:22:02,130
但是你要写普罗米修斯

445
00:22:02,131 --> 00:22:03,450


446
00:22:03,451 --> 00:22:04,440
Skywalking等等

447
00:22:04,441 --> 00:22:05,970
各种C模块的话

448
00:22:05,971 --> 00:22:07,680
其实你的工作量会非常的大

449
00:22:09,180 --> 00:22:10,230
对然后呢

450
00:22:10,231 --> 00:22:18,450
在云原生下面还有一个很重要的就是我们的流量不再只是HTTP和HTTPS流量

451
00:22:18,451 --> 00:22:19,590
我们会有很多RPC

452
00:22:19,591 --> 00:22:20,640
流量

453
00:22:20,641 --> 00:22:21,990
有一些是

454
00:22:21,991 --> 00:22:24,090
甚至是用户自定义的RPC的流量

455
00:22:25,200 --> 00:22:27,000
对啊这个时候呢

456
00:22:27,001 --> 00:22:31,380
协议的转换对于API网关来说就是一个非常重要的功能

457
00:22:31,381 --> 00:22:34,590
我们可以不仅支持HTTP、HTTPS

458
00:22:34,591 --> 00:22:37,770
我们还希望能够支持GRPC

459
00:22:37,771 --> 00:22:42,600
Apache Dubbo或者是腾讯的TARS等等各种各样的服务

460
00:22:42,601 --> 00:22:51,360
甚至是用户自定义的一些RPC的协议都可以在网关层面去做一些这样的转化和处理

461
00:22:51,361 --> 00:22:53,940
那么如果这个时候你用了一个NGINX

462
00:22:53,941 --> 00:22:55,860
其实你是非常困难

463
00:22:56,970 --> 00:22:57,630
然后呢

464
00:22:57,631 --> 00:22:58,350
除了这些之外

465
00:22:58,351 --> 00:23:01,380
我们也希望他能够很好的去支持

466
00:23:01,381 --> 00:23:01,980
多云

467
00:23:01,981 --> 00:23:03,870
混合云K8S友好

468
00:23:03,871 --> 00:23:07,350
我们可以很方便的在容器里面跑起来

469
00:23:07,351 --> 00:23:08,640
我们有非常方便的

470
00:23:08,641 --> 00:23:11,910
这种和HELM CHART是这种包管理器等等之类的

471
00:23:13,830 --> 00:23:17,460
这都在云原生下面的这种新的一些要求

472
00:23:19,530 --> 00:23:19,830
嗯

473
00:23:19,831 --> 00:23:25,860
除了从技术层面上来看的我们也可以从商业的视角来看一下API网关领域

474
00:23:25,861 --> 00:23:27,840
这是让我们最开始提到的一样

475
00:23:27,841 --> 00:23:33,300
API网关里面可能是一个比较古老的这样的一个产品

476
00:23:33,301 --> 00:23:36,030
相对于可观测性啊

477
00:23:36,031 --> 00:23:38,280
然后零信任、身份认证等等

478
00:23:38,281 --> 00:23:42,120
这些他和云原生里面的其他的开源项目比起来

479
00:23:42,121 --> 00:23:45,090
API网关是一个和数据库差不多古老的

480
00:23:45,091 --> 00:23:51,600
这样的一个组件在这个领域里面有非常多的头部的玩家

481
00:23:51,601 --> 00:23:53,130
这个是GANTER

482
00:23:53,131 --> 00:23:57,120
2019年的一个一个报告

483
00:23:57,121 --> 00:23:57,870
这个报告呢

484
00:23:57,871 --> 00:24:03,390
里面的所有的厂商都是去做API全生命周期管理的

485
00:24:03,391 --> 00:24:06,150
那么什么是API全生命周期管理呢

486
00:24:06,151 --> 00:24:18,780
API生命周期管理指的是从API的设计到API的文档和他的SDK以及他的API的上线之类的一整套的解决方案

487
00:24:18,781 --> 00:24:24,240
甚至还包括API的市场等等一整套的解决方案

488
00:24:24,241 --> 00:24:27,210
网关了在里面是一个比较重要的一个角色

489
00:24:27,211 --> 00:24:28,920
是他的一个核心组件

490
00:24:30,120 --> 00:24:33,030
我们可以看到了在右上角的GANTER报告的右上角了

491
00:24:33,031 --> 00:24:37,590
就是在他的这个领导者的这个位置上面全都是一些巨头

492
00:24:37,591 --> 00:24:39,480
比如说谷歌

493
00:24:39,481 --> 00:24:40,800
比如说IBM

494
00:24:40,801 --> 00:24:43,500
比如说SALESEFORCE等等

495
00:24:43,501 --> 00:24:46,200
都是一些公有云的巨头

496
00:24:46,201 --> 00:24:48,480
他们也会不会去

497
00:24:48,481 --> 00:24:51,090
有这样的API全生命周期的这样一些产品

498
00:24:52,230 --> 00:24:59,550
恩但是还有一个很有趣的一个点的就是在右下角右下角的就是援建者了

499
00:24:59,551 --> 00:25:00,180
这样一个位置

500
00:25:00,181 --> 00:25:01,860
援建者里面其实很多

501
00:25:01,861 --> 00:25:03,600
都是开源项目

502
00:25:03,601 --> 00:25:06,060
比如说KONG是一个开源项目

503
00:25:06,061 --> 00:25:09,030
WS02也是一个开源项目

504
00:25:09,031 --> 00:25:10,830
红帽代表的3SCALE

505
00:25:10,831 --> 00:25:12,840
他也是一个开源项目

506
00:25:12,841 --> 00:25:14,250
也就是说

507
00:25:14,251 --> 00:25:15,990
在Api这个领域里面

508
00:25:15,991 --> 00:25:19,560
领导者都是公有云的闭源项目

509
00:25:19,561 --> 00:25:23,190
而且是和他的公有云服务是强绑定的

510
00:25:23,191 --> 00:25:24,210
这样的一些闭源项目

511
00:25:24,211 --> 00:25:27,300
但是在挑战者里面的都是一些开源项目

512
00:25:27,301 --> 00:25:29,850
这其实就是一个很有趣的一个点

513
00:25:29,851 --> 00:25:30,330
所以呢

514
00:25:30,331 --> 00:25:32,250
我们经常提到的是

515
00:25:32,251 --> 00:25:33,780
软件在吞噬世界

516
00:25:33,781 --> 00:25:35,250
然后开源软件呢

517
00:25:35,251 --> 00:25:36,960
在吞噬软件

518
00:25:36,961 --> 00:25:39,300
所以云原生和软件其实是绑得非常紧

519
00:25:41,460 --> 00:25:45,990
这里面我列出了一些和API网关厂商相关的一些收购

520
00:25:45,991 --> 00:25:47,490
比如说从2015年开始

521
00:25:47,491 --> 00:25:51,030
IBM和谷歌就已经在收购API厂商了

522
00:25:51,031 --> 00:25:52,530
那个时候其实金额还不大

523
00:25:52,531 --> 00:25:54,660
但是18年的时候金额就越来越大

524
00:25:54,661 --> 00:25:56,490
SALESFORCE六十多亿

525
00:25:56,491 --> 00:25:59,490
收购了MuleSoft 18年的时候呢

526
00:25:59,491 --> 00:26:05,700
Broadcom 189亿收购了CA 当然MuleSoft和CA做的不只是API网关

527
00:26:05,701 --> 00:26:09,120
但是他们的核心的产品都是和API相关的

528
00:26:09,121 --> 00:26:12,750
并在此基础上进行了一些延展

529
00:26:12,751 --> 00:26:13,440
2019年了

530
00:26:13,441 --> 00:26:15,510
我们大家都知道F5收购了NGINX

531
00:26:17,040 --> 00:26:17,340
其实

532
00:26:17,341 --> 00:26:22,080
如果单独看来F5收购NGINX, 可能大家觉得这个可能一个开源项目卖了快十亿美金

533
00:26:22,081 --> 00:26:23,220
觉得还不错

534
00:26:23,221 --> 00:26:26,640
但是如果我们把这些数据放在一起去看了

535
00:26:26,641 --> 00:26:30,510
其实就觉得NGINX是一个大家用得如此的

536
00:26:31,950 --> 00:26:34,650
普及而且做的如此的好的一个项目

537
00:26:35,760 --> 00:26:37,680
一个非常优秀的一个开源项目

538
00:26:37,681 --> 00:26:42,450
但是和MuleSoft和CA比起来就是它的估值会非常的低

539
00:26:45,180 --> 00:26:48,330
这就是我刚才提到了NGINX之所以没有做好呢

540
00:26:48,331 --> 00:26:54,030
其实更多的原因是因为在云原生和微服务里面

541
00:26:54,031 --> 00:26:56,820
他并没有去抓住这样一个机会

542
00:26:56,821 --> 00:27:01,380
虽然他尝试去做了NGIX的INGRESS CONTROLLER

543
00:27:01,381 --> 00:27:03,900
尝试去做了NGINX unit

544
00:27:03,901 --> 00:27:11,790
但是他们都没有摆脱NGINX开源版本的这种影响一直都没有把动态能力加到里去

545
00:27:11,791 --> 00:27:13,650
这其实就会非常影响他

546
00:27:13,651 --> 00:27:17,400
在云原生和微服务这种里面这种市场占有率

547
00:27:18,480 --> 00:27:20,700
其他的商业化也一直并不成功

548
00:27:22,830 --> 00:27:23,400
恩后面

549
00:27:23,401 --> 00:27:26,280
我说下一下APISIX

550
00:27:26,281 --> 00:27:32,160
其实它是基于NGINX来做了对哦

551
00:27:32,161 --> 00:27:33,000
我们都知道

552
00:27:33,990 --> 00:27:39,720
OPEN RESTY是在NGINX的基础里面加了一个LUA的一个MODULE

553
00:27:39,721 --> 00:27:41,730
一个第三方的一个C模块

554
00:27:41,731 --> 00:27:45,000
然后形成了OpenResty

555
00:27:45,001 --> 00:27:49,170
那个APISIX是在OpenResty的基础之上扩展了用LUA

556
00:27:49,171 --> 00:27:52,050
扩展了非常多的这种路由

557
00:27:52,051 --> 00:27:54,510
然后插件等等

558
00:27:54,511 --> 00:27:57,960
各种各样的这种功能把它做成了一个开箱即用的网关产品

559
00:28:00,300 --> 00:28:02,640
如果用一句话来形容了APISIX呢

560
00:28:02,641 --> 00:28:04,230
你就说我们希望APISIX

561
00:28:04,231 --> 00:28:05,640
做成一个云原生

562
00:28:05,641 --> 00:28:08,340
的API网关

563
00:28:08,341 --> 00:28:11,070
对我们来说就是全动态

564
00:28:11,071 --> 00:28:21,810
然后更加丰富的生态以及我们用更加开放的这种心态去融入到开源里面去

565
00:28:21,811 --> 00:28:24,030
如果大家去贡献过NGINX

566
00:28:25,020 --> 00:28:27,390
代码的话你会发现NGINX

567
00:28:27,391 --> 00:28:28,020
其实

568
00:28:28,980 --> 00:28:31,590
一直都没有融入到开源社区里面去

569
00:28:32,580 --> 00:28:35,430
因为你在这个GITHUB上面去

570
00:28:35,431 --> 00:28:37,590
没有办法给NGINX提交ISSUE

571
00:28:37,591 --> 00:28:39,930
也没有给办法给他贡献代码

572
00:28:39,931 --> 00:28:42,360
他所有的还是用在mercurial

573
00:28:42,361 --> 00:28:46,350
这种很古老的这种代码管理仓库里面

574
00:28:46,351 --> 00:28:48,780
你如果要给他提一个ISSUE

575
00:28:48,781 --> 00:28:50,010
如果要给他提一个bug

576
00:28:50,011 --> 00:28:53,940
你要用diff去找出代码的差异

577
00:28:53,941 --> 00:28:57,720
然后用邮件的方式去提给这个社区

578
00:28:57,721 --> 00:28:58,680
所以呢

579
00:28:58,681 --> 00:29:01,080
他对开源社区的融入并不是很好

580
00:29:03,180 --> 00:29:05,130
APISIX是中国最快毕业的开源项目

581
00:29:05,131 --> 00:29:05,670
看一下吧

582
00:29:05,671 --> 00:29:07,950
我们只用了九个月就毕业了

583
00:29:07,951 --> 00:29:10,530
但这是我们现在迄今为止中国最快毕业了

584
00:29:10,531 --> 00:29:11,400
然后他就Apache顶级项目

585
00:29:12,540 --> 00:29:13,830
对于APISIX来说呢

586
00:29:13,831 --> 00:29:16,050
他生来就是为了动态

587
00:29:16,051 --> 00:29:17,610
他就是动态

588
00:29:17,611 --> 00:29:19,200
就是他天生的一种能力

589
00:29:19,201 --> 00:29:22,320
我们对APISIX的所有设计包括路

590
00:29:22,321 --> 00:29:25,020
由证书上游甚至插件

591
00:29:25,021 --> 00:29:27,060
本身都是动态的

592
00:29:27,061 --> 00:29:28,230
而插件的动态呢

593
00:29:28,231 --> 00:29:33,090
其实是APISIX独有的插件的动态呢的意思是说

594
00:29:33,091 --> 00:29:36,270
我把插件的本身也做成了热插拔

595
00:29:36,271 --> 00:29:39,210
如果我们新增了一个插件或者修改了

596
00:29:39,211 --> 00:29:40,890
某一个插件的代码

597
00:29:40,891 --> 00:29:44,220
我们传统的想法都是我既然都改了代码了

598
00:29:44,221 --> 00:29:46,620
那我肯定要重启服务才能生效啊

599
00:29:46,621 --> 00:29:49,200
但是在APISIX里面不用

600
00:29:49,201 --> 00:29:51,270
如果没有修改内核代码

601
00:29:51,271 --> 00:29:53,160
只是修改了插件的代码

602
00:29:53,161 --> 00:29:54,840
或者是新增了一个插件

603
00:29:54,841 --> 00:29:58,950
你只用调一个RESTFUL API这个插件就可以工作

604
00:29:58,951 --> 00:30:02,700
在内存里面就即刻去生效

605
00:30:02,701 --> 00:30:05,490
这APISIX独有的我插件也做成了一个热插拔

606
00:30:06,750 --> 00:30:09,810
然后现在APISIX已经有了四十多个插件

607
00:30:09,811 --> 00:30:14,430
覆盖了基本上大家常用的一些第三方的开源项目

608
00:30:14,431 --> 00:30:19,290
以及对接了一些常用的SAAS的一些厂商已经覆盖了身份认证

609
00:30:19,291 --> 00:30:19,830
完全一致

610
00:30:19,831 --> 00:30:20,820
可观测性等等

611
00:30:20,821 --> 00:30:22,020
大家常用的一些各个方面

612
00:30:24,690 --> 00:30:28,290
APISIX是在去年六月份开源的

613
00:30:28,291 --> 00:30:36,930
然后APISIX在我们从构思APISIX到真正去写下一篇APISIX的第一行代码

614
00:30:36,931 --> 00:30:37,440
我们花

615
00:30:38,400 --> 00:30:39,570
那大概有两个月的时间

616
00:30:40,500 --> 00:30:41,130
这两月的时间

617
00:30:41,131 --> 00:30:44,190
我们主要是在去设计APISIX

618
00:30:44,191 --> 00:30:47,070
我们所要思考就是APISIX做成一个什么样子

619
00:30:47,071 --> 00:30:49,350
我们通过一些什么样的方式

620
00:30:50,460 --> 00:30:53,940
做APISIX 最终能给用户带来一些什么东西

621
00:30:53,941 --> 00:30:55,830
这上面我们会想的比较多一些

622
00:30:55,831 --> 00:30:58,620
APISIX设计的思路

623
00:30:58,621 --> 00:31:00,030
其实主要就是以下几点

624
00:31:01,230 --> 00:31:01,770
首先呢

625
00:31:01,771 --> 00:31:05,160
他是一个数据平面和控制平面分离的

626
00:31:06,330 --> 00:31:11,490
对就是我们希望我们的控制面不仅能控制APISIX

627
00:31:11,491 --> 00:31:13,650
我还可以控制其他我的数据

628
00:31:13,651 --> 00:31:16,410
平面不仅可以背一篇适合自己的控制面控制

629
00:31:16,411 --> 00:31:18,450
我还可以被其他的控制来控制

630
00:31:18,451 --> 00:31:21,150
能够把这块就完全分离开

631
00:31:21,151 --> 00:31:23,010
这是第一个第二个的是

632
00:31:23,011 --> 00:31:28,020
我希望通过灵活的插件机制来做二次开发

633
00:31:28,021 --> 00:31:32,310
所以在APISIX里面做二次开发是非常简单的

634
00:31:32,311 --> 00:31:35,550
如果大家使用过Envoy或者是Kong的话

635
00:31:35,551 --> 00:31:39,510
你可以对比一下Envoy的插件是用C++来写

636
00:31:39,511 --> 00:31:40,800
这个难度会比较大

637
00:31:40,801 --> 00:31:42,660
如果你编译一下Envoy

638
00:31:42,661 --> 00:31:47,070
你会发现你会发花非常长的时间才能把Envoy给编译通过

639
00:31:47,071 --> 00:31:47,250


640
00:31:48,510 --> 00:31:49,470
在Kong里面呢

641
00:31:49,471 --> 00:31:52,710
你要边你要写一个限流限速的插件

642
00:31:52,711 --> 00:31:54,570
需要写三百多行代码

643
00:31:54,571 --> 00:31:57,330
分布在四五个不同的文件里面去

644
00:31:57,331 --> 00:32:00,900
你才可以完成一个限流限速的插件

645
00:32:00,901 --> 00:32:02,730
但是在APISIX里面呢

646
00:32:02,731 --> 00:32:06,570
你只用写一个 在一个文件里面写70行代码

647
00:32:06,571 --> 00:32:08,880
你就可以完成同样的一个操作

648
00:32:10,650 --> 00:32:16,920
对所以我们在方便二次开发上面去做了很多的这样的一些设计

649
00:32:16,921 --> 00:32:20,310
同时APISIX是没有单点故障了

650
00:32:20,311 --> 00:32:23,070
从他的数据平面到他的控制平面

651
00:32:24,060 --> 00:32:26,820
宕掉任意台服务器都是不会有影响的

652
00:32:26,821 --> 00:32:28,770
所以我其实我们为什么选用etcd

653
00:32:29,910 --> 00:32:34,350
就是希望我们的系统除了网关节点自身是无状态

654
00:32:34,351 --> 00:32:40,530
我也希望我的存储数据和负责数据分发的这个存储也是没有单点故障

655
00:32:40,531 --> 00:32:41,610
所以我们选用etcd

656
00:32:43,530 --> 00:32:44,880
另外呢

657
00:32:44,881 --> 00:32:47,040
为什么我会基于Nginx来做

658
00:32:47,041 --> 00:32:51,960
因为我们觉得Nginx是一个非常优秀的一个开源项目

659
00:32:51,961 --> 00:32:52,590
Nginx

660
00:32:52,591 --> 00:32:54,180
C的代码

661
00:32:54,181 --> 00:33:00,870
他在内存以及它的一些性能优化上已经做到了一个极致

662
00:33:01,920 --> 00:33:06,480
NGINX的底层开发做的非常非常的好

663
00:33:06,481 --> 00:33:09,120
所以我们觉得而且它运行了这么多年

664
00:33:09,121 --> 00:33:11,610
所以我们觉得如果从稳定性上来说

665
00:33:11,611 --> 00:33:15,060
从高性能的角度来说Nginx是一个最佳的选择

666
00:33:15,061 --> 00:33:17,970
但是Nginx是并不完美

667
00:33:17,971 --> 00:33:19,350
因为他没有动态

668
00:33:19,351 --> 00:33:21,510
所以在APISIX里面

669
00:33:21,511 --> 00:33:24,480
我们只用了Nginx的网络层

670
00:33:24,481 --> 00:33:25,860
其他的包括路

671
00:33:25,861 --> 00:33:27,810
由插件等等

672
00:33:27,811 --> 00:33:29,730
这些东西我们全都没有用

673
00:33:29,731 --> 00:33:31,170
大家在Nginx用的

674
00:33:31,171 --> 00:33:32,700
比如说一个location

675
00:33:32,701 --> 00:33:35,010
然后后面接了一个URI

676
00:33:35,011 --> 00:33:37,620
这样的东西我们全都没有用

677
00:33:37,621 --> 00:33:40,170
我们全部都是全部重写掉

678
00:33:40,171 --> 00:33:41,820
所以我们才能做到全部的动态

679
00:33:43,380 --> 00:33:43,770
嗯

680
00:33:43,771 --> 00:33:46,050
还有一个就比如说双向认证

681
00:33:46,051 --> 00:33:49,380
以及我们把敏感信息去加盐加密了去保存

682
00:33:49,381 --> 00:33:52,500
这都是我们在最初设计的时候就加到里面去

683
00:33:53,610 --> 00:33:54,210
另外一个了

684
00:33:54,211 --> 00:33:56,700
我们觉得和其他的网关相比

685
00:33:56,701 --> 00:34:03,990
APISIX的性能是最容易被用户给去做这种对比测试给探出来

686
00:34:03,991 --> 00:34:07,230
所以我们在自己的单核心的QPS

687
00:34:07,231 --> 00:34:09,960
我们用WRK去做压测

688
00:34:09,961 --> 00:34:10,590
我们单核

689
00:34:10,591 --> 00:34:12,870
QPS可以轻松超过一.五万

690
00:34:12,871 --> 00:34:14,760
然后在CPU跑满的情况下

691
00:34:14,761 --> 00:34:17,010
延迟低于零点七毫秒

692
00:34:17,011 --> 00:34:18,690
就是和我们延迟是低于一毫秒

693
00:34:20,490 --> 00:34:22,260
说这些之外的我们也知道

694
00:34:22,261 --> 00:34:25,050
很多API网关其实是运维在使用

695
00:34:25,051 --> 00:34:27,990
所以像Prometheus、Skywalking

696
00:34:27,991 --> 00:34:31,980
这些组件的支持我们都是第一时间去增加上去

697
00:34:31,981 --> 00:34:34,080
现在API网关里面支持Skywalking的

698
00:34:34,081 --> 00:34:35,370
应该就只有APISIX

699
00:34:36,570 --> 00:34:39,690
然后我们在Promethues上面做了非常多的优化

700
00:34:39,691 --> 00:34:42,480
同时我们也只支持流量复制、故障注入等等

701
00:34:42,481 --> 00:34:46,020
这些经常会用到的一些功能

702
00:34:48,000 --> 00:34:52,020
这个是APISIX的一个技术的一个架构图

703
00:34:52,021 --> 00:34:54,270
我们可以看到最左侧是他的DP

704
00:34:54,271 --> 00:34:56,670
也就是他的数据平面在右侧

705
00:34:56,671 --> 00:34:58,410
是他的控制平面

706
00:34:58,411 --> 00:35:00,840
这两个平面的是完全剥离开的

707
00:35:00,841 --> 00:35:03,930
他们之间只通过了ETCD来通信

708
00:35:03,931 --> 00:35:08,730
我管理员的数据控制数据写在了ETCD里面

709
00:35:08,731 --> 00:35:14,100
然后我的数据平面通过ETCD的WATCH接口去获取这些数据

710
00:35:14,101 --> 00:35:15,150
然后呢

711
00:35:15,151 --> 00:35:17,460
在内存里面直接就可以生效了

712
00:35:18,450 --> 00:35:20,430
这个是他简单的一个架构图

713
00:35:20,431 --> 00:35:24,420
所以从里面可以看到整个架构会比较的清晰

714
00:35:27,150 --> 00:35:29,880
这个是APISIX的一个生态图

715
00:35:29,881 --> 00:35:32,850
就是我们可以看到APISIX处理的协议

716
00:35:32,851 --> 00:35:34,950
不止有Http、Https

717
00:35:34,951 --> 00:35:40,140
还有一些GRPC、MQTT这样了一些协议

718
00:35:40,141 --> 00:35:46,410
所以APISIX你可以把它当做一个传统的南北

719
00:35:46,411 --> 00:35:48,810
向的流量也可以去处理一下

720
00:35:48,811 --> 00:35:56,220
IOT的这样的设备的一些流量对然后最右侧是我们接了外部的一些服务

721
00:35:57,180 --> 00:36:01,560
恩因为Apisix自己使用的Etcd所以呢

722
00:36:01,561 --> 00:36:07,590
我们当然会支持Etcd做一个服务注册服务发现的中心来使用

723
00:36:07,591 --> 00:36:08,550
但是除此之外呢

724
00:36:08,551 --> 00:36:11,220
我们也支持那些Consul、Eureka

725
00:36:11,221 --> 00:36:12,330
Nacos等等

726
00:36:12,331 --> 00:36:18,240
各种各样的这种服务发现的这些组件可以和ApiSix去做对接

727
00:36:20,880 --> 00:36:23,520
这些其实大部分的网关都有这个功能

728
00:36:23,521 --> 00:36:28,200
然后后面我们会提一些APISIX独有的一些功能

729
00:36:31,110 --> 00:36:32,640
恩再说这个独有功能

730
00:36:32,641 --> 00:36:36,150
之前我们可以看下Apisix可以帮助大家做什么

731
00:36:36,151 --> 00:36:36,960
Apisix呢

732
00:36:36,961 --> 00:36:41,070
可以处理四层和七层的各种各样的协议

733
00:36:41,071 --> 00:36:41,430
所以呢

734
00:36:41,431 --> 00:36:43,740
你可以把Apisix替代Nginx

735
00:36:43,741 --> 00:36:46,980
去处理南北向流量也可以替代

736
00:36:46,981 --> 00:36:49,200
Envoy去做东西向的能量

737
00:36:49,201 --> 00:36:50,790
同时我们有一个开源项目

738
00:36:50,791 --> 00:36:54,450
是把Apisix用做了K8S的Ingress Controller

739
00:36:54,451 --> 00:36:57,180
已经有好几家公司已经把

740
00:36:57,181 --> 00:37:00,900
把K8S Ingress Controller上了生产系统

741
00:37:00,901 --> 00:37:06,150
同时借助MQTT插件可以做IOT的网关接入身份认证的一种插件呢

742
00:37:06,151 --> 00:37:08,100
可以成为一个零信任的网关

743
00:37:08,101 --> 00:37:12,990
所以Apisix我们提供了一个内核和常用的插件

744
00:37:12,991 --> 00:37:16,110
至于你可以把它做成什么样的一些事情

745
00:37:16,111 --> 00:37:18,630
其实就非常具有一些自己的一些想象力

746
00:37:21,360 --> 00:37:23,940
后面会提到ApiSix的技术优势

747
00:37:23,941 --> 00:37:27,240
我这里主要写了六点了

748
00:37:27,241 --> 00:37:30,900
之前的都是我们在底层上面的一些优化

749
00:37:30,901 --> 00:37:36,600
比如说我刚才提到的Apisix并没有使用Nginx的路由

750
00:37:36,601 --> 00:37:45,690
而是自己通过技术树重新做了一套路由 Apisix路由的时间复杂度是O(k)这个K呢

751
00:37:45,691 --> 00:37:47,820
指的是uri的一个长度

752
00:37:47,821 --> 00:37:50,400
也就是说用户请求的URI的一个长度

753
00:37:50,401 --> 00:37:53,280
和路由数量是没有关系的

754
00:37:53,281 --> 00:37:55,470
比如说你有一百条路

755
00:37:55,471 --> 00:37:58,560
由规则或者是一百万条路的位置

756
00:37:58,561 --> 00:38:02,400
对Apisix匹配的时间复杂度都是一样

757
00:38:04,620 --> 00:38:05,700
而Kong的呢

758
00:38:05,701 --> 00:38:07,290
他的路由的时间复杂度匹配是N

759
00:38:07,291 --> 00:38:08,970
你这么说

760
00:38:08,971 --> 00:38:10,410
你一百条和一百万条

761
00:38:10,411 --> 00:38:12,990
它的时间复杂就差了一万倍

762
00:38:12,991 --> 00:38:15,750
所以我们在尽量做性能测试的时候呢

763
00:38:15,751 --> 00:38:17,490
你不要只是测几十条

764
00:38:17,491 --> 00:38:19,230
几百条路由其实

765
00:38:20,340 --> 00:38:21,870
在几百条的这种情况下

766
00:38:21,871 --> 00:38:24,060
时间复杂度是O(1)还是O(n)

767
00:38:24,061 --> 00:38:25,530
甚至是O的N次方

768
00:38:25,531 --> 00:38:27,930
他其实都差不多

769
00:38:27,931 --> 00:38:30,030
但是你如果几万条的话

770
00:38:30,031 --> 00:38:33,000
这个性能的差异就一下子就拉开了

771
00:38:34,920 --> 00:38:38,160
第二是ApiSix的IP的匹配

772
00:38:38,161 --> 00:38:38,970
因为我们知道

773
00:38:38,971 --> 00:38:41,730
在网关层面的我们经常会做一些IP的匹配

774
00:38:41,731 --> 00:38:46,440
比如说我们根据不同的地区去扔到不同的上游服务

775
00:38:46,441 --> 00:38:49,260
或者是有一个IP的黑白名单

776
00:38:49,261 --> 00:38:51,630
那么这个时候IP匹配就会非常的重要

777
00:38:51,631 --> 00:38:52,170
很多时候

778
00:38:52,171 --> 00:38:54,270
我们的IP黑名单可能有几万个IP

779
00:38:55,260 --> 00:38:58,890
ApiSix ip的时间复杂度是O(1)

780
00:38:58,891 --> 00:38:59,370
也就是说

781
00:38:59,371 --> 00:39:02,100
不管有多少IP都是一次命中

782
00:39:03,930 --> 00:39:05,100
那么在Kong里面

783
00:39:05,101 --> 00:39:06,300
它其实原来是o(n)

784
00:39:06,301 --> 00:39:10,830
然后他最近的版本的也换了Apisix的这种匹配库就直接使用了

785
00:39:10,831 --> 00:39:13,080
我们的我们自己写的IP匹配库

786
00:39:13,081 --> 00:39:15,390
把这个东西拿到Kong里边去了

787
00:39:15,391 --> 00:39:17,160
所以他现在时间复杂度也是O(1)

788
00:39:18,480 --> 00:39:19,050
第三个呢

789
00:39:19,051 --> 00:39:22,080
就是我之前提到的在做灰度发布的时候

790
00:39:22,081 --> 00:39:24,510
那ApiSix会更加的丰富

791
00:39:24,511 --> 00:39:26,910
我们可以接受Nginx的所有变量

792
00:39:26,911 --> 00:39:29,130
作为条件并且支持Lua

793
00:39:29,131 --> 00:39:30,540
自己去写自定义函数

794
00:39:32,820 --> 00:39:35,070
第四个也是之前提到我们使用Etcd

795
00:39:35,071 --> 00:39:36,090
所以没有单点

796
00:39:38,010 --> 00:39:39,840
第五个和第四个是相关的

797
00:39:39,841 --> 00:39:41,520
因为我们使用了ETCD

798
00:39:41,521 --> 00:39:43,020
所以我们通过Etcd的Watch

799
00:39:43,021 --> 00:39:48,150
可以在毫秒级别就能把管理员的配置下发的所有环境节点

800
00:39:48,151 --> 00:39:50,100
而其他网关了是定期轮训的

801
00:39:50,101 --> 00:39:53,310
所以一般需要五秒到十秒才能拿到这个最新的配置

802
00:39:54,570 --> 00:39:56,250
第六个就会比较细节

803
00:39:56,251 --> 00:40:04,470
因为一些用户他可能不止是类似于一些简单的round robin 一致性哈希

804
00:40:04,471 --> 00:40:06,390
的这种负载均衡算法

805
00:40:06,391 --> 00:40:08,190
他要制定一个自定义负载均衡算法

806
00:40:08,191 --> 00:40:12,420
那么ApiSix是把这块的挂载点也是开放出来了

807
00:40:15,120 --> 00:40:16,410
而这里有一个视频

808
00:40:16,411 --> 00:40:18,390
提供了我们独创的一个功能

809
00:40:18,391 --> 00:40:20,280
就是叫做插件编排

810
00:40:20,281 --> 00:40:23,250
然后我们可以看一下这个视频哦

811
00:40:23,251 --> 00:40:24,180
一般来说呢

812
00:40:24,181 --> 00:40:27,450
插件的之间都是没有关系的

813
00:40:27,451 --> 00:40:30,030
比如说我这里放了一个Uri block

814
00:40:30,031 --> 00:40:32,460
更像一个Uri的一个黑白名单

815
00:40:32,461 --> 00:40:33,900
那个插件对吧

816
00:40:33,901 --> 00:40:35,850
当他命中某一个条件的时候

817
00:40:35,851 --> 00:40:38,670
比如说一个URI被拦截了

818
00:40:38,671 --> 00:40:40,230
命中我的拦截规则

819
00:40:40,231 --> 00:40:42,600
我就把他扔到一个故障注入插件

820
00:40:42,601 --> 00:40:44,100
我给

821
00:40:44,101 --> 00:40:45,240
如果他没有命中了

822
00:40:45,241 --> 00:40:46,590
我就丢给一个Kafka了

823
00:40:46,591 --> 00:40:47,550
记日志的一个插件

824
00:40:49,020 --> 00:40:49,860
那么

825
00:40:49,861 --> 00:40:53,010
在传统里面的我需要先写一个全新的插件

826
00:40:53,011 --> 00:40:54,570
才能完成这个功能

827
00:40:54,571 --> 00:40:57,390
但是能通过我们自己的插件编排

828
00:40:57,391 --> 00:41:03,570
我们可以在界面上拖拖拽拽的这种方式就可以先生成一个全新的插件

829
00:41:03,571 --> 00:41:08,910
让插件的之间的数据得到了一个共享

830
00:41:08,911 --> 00:41:11,070
这个是之前所有的API网关

831
00:41:11,071 --> 00:41:13,350
都没有API网关都有插件

832
00:41:13,351 --> 00:41:16,080
但是这些插件都是完全隔离开的

833
00:41:16,081 --> 00:41:18,000
互相不感知的

834
00:41:18,001 --> 00:41:19,740
那么在Apisix里面呢

835
00:41:19,741 --> 00:41:26,430
我们通过这种插件编排的方式可以把Apisix的四十多个插件

836
00:41:26,431 --> 00:41:29,340
他们的上下游的关系全部串联起来

837
00:41:29,341 --> 00:41:31,830
可以做成一个全新的插件

838
00:41:32,940 --> 00:41:34,380
这个是怎么去做的呢

839
00:41:36,180 --> 00:41:37,470
恩我们说一下

840
00:41:37,471 --> 00:41:38,910
为什么我们需要这么去做吧

841
00:41:38,911 --> 00:41:40,740
就是对于网关来说呢

842
00:41:40,741 --> 00:41:42,390
一直都有一个痛点

843
00:41:42,391 --> 00:41:44,070
这个痛点是什么呢

844
00:41:44,071 --> 00:41:44,820
就是

845
00:41:45,750 --> 00:41:51,720
恩我们都想尽量的去降低用户二次开发的难度

846
00:41:51,721 --> 00:41:56,820
比如说Kong和ApiSix都是用Lua来写的

847
00:41:56,821 --> 00:41:59,310
但是那Lua是一个相对小众的语言

848
00:41:59,311 --> 00:42:01,620
所以Kong的解决方案就是Ok

849
00:42:01,621 --> 00:42:02,850
既然Lua不好写

850
00:42:02,851 --> 00:42:05,670
那么我用go语言写可不可以呢

851
00:42:05,671 --> 00:42:06,630
这是一个方法

852
00:42:06,631 --> 00:42:10,320
所以Kong就支持用go来编写插件

853
00:42:10,321 --> 00:42:10,950
然后呢

854
00:42:10,951 --> 00:42:11,100
嗯

855
00:42:11,101 --> 00:42:12,930
Envoy就更是这样子了

856
00:42:12,931 --> 00:42:15,660
用C++来写Envoy的Filter

857
00:42:15,661 --> 00:42:17,400
就难度就更大了

858
00:42:17,401 --> 00:42:19,020
所以Envoy的做法是说呢

859
00:42:19,021 --> 00:42:19,710
既然C++

860
00:42:19,711 --> 00:42:20,970
大家不愿意写

861
00:42:20,971 --> 00:42:25,770
那么我这是Lua这个写插件可不可以呢

862
00:42:25,771 --> 00:42:27,000
或者Lua也小众

863
00:42:27,001 --> 00:42:29,610
我支持WASM各种语言Filter

864
00:42:29,611 --> 00:42:31,110
他可不可以呢

865
00:42:31,111 --> 00:42:32,910
这也是一个思路

866
00:42:32,911 --> 00:42:34,860
但是我们思路不一样

867
00:42:34,861 --> 00:42:38,820
为什么一个网关就一定要写代码

868
00:42:38,821 --> 00:42:44,820
为什么像奥布斯和产品经理不能直接去做一个新的插件出来了

869
00:42:44,821 --> 00:42:50,940
其实奥布斯和PM是一片网关里面最常用的需求的提出方

870
00:42:50,941 --> 00:42:54,300
为什么他提出这个需求不可以自己造一个插件

871
00:42:54,301 --> 00:42:56,490
一定要工程师去写个插件

872
00:42:56,491 --> 00:42:56,820
所以呢

873
00:42:56,821 --> 00:43:00,510
我们的解决方案其实就

874
00:43:00,511 --> 00:43:02,040
会可能会更彻底一点

875
00:43:02,041 --> 00:43:05,070
我们希望能够做到一个低代码的API网关

876
00:43:05,071 --> 00:43:06,690
我们希望用户不再写插件

877
00:43:06,691 --> 00:43:08,670
就在界面上拖拖拽拽

878
00:43:08,671 --> 00:43:13,320
把Apisix提供的四十多个插件能够拖拖拽拽

879
00:43:13,321 --> 00:43:17,850
已经可以排列组合出无限种可能性

880
00:43:17,851 --> 00:43:20,160
但是这个东西并不是所有网关都可以做的

881
00:43:21,480 --> 00:43:23,760
恩他需要你的底层架构和插件

882
00:43:23,761 --> 00:43:25,770
能够足够的灵活

883
00:43:25,771 --> 00:43:29,190
你才可以做得到这样一个效果 ApiSix这块东西呢

884
00:43:29,191 --> 00:43:32,130
其实已经做好已经开经开源出来了

885
00:43:32,131 --> 00:43:33,060
关于细节的问题

886
00:43:33,061 --> 00:43:38,940
我们会在月底会给大家会聊里面其他更多

887
00:43:38,941 --> 00:43:41,190
这些细节你们细节还是比较有趣

888
00:43:43,260 --> 00:43:45,270
Apisix开源了一年多的时间呢

889
00:43:45,271 --> 00:43:48,960
其实已经有非常多的企业用户去使用了

890
00:43:48,961 --> 00:43:52,800
然后这里只是列出了一些大概的一些厂商

891
00:43:52,801 --> 00:43:54,300
这里是一个分类

892
00:43:54,301 --> 00:43:56,520
比如说公有云里面腾讯

893
00:43:56,521 --> 00:43:57,030
华为

894
00:43:57,031 --> 00:44:00,180
中国移动、DaoCloud 的这些公有云的厂商呢

895
00:44:00,181 --> 00:44:02,340
都在使用ApiSix

896
00:44:02,341 --> 00:44:08,040
另外一个比较有趣的就是很多航天的这样的一些公司在使用

897
00:44:08,041 --> 00:44:13,140
比如说NASA美国航空航天局以及中国航信航天智云等等

898
00:44:13,141 --> 00:44:16,350
他们都在用Apisix去处理下

899
00:44:16,351 --> 00:44:19,260
NASA是处理一些宇宙探索的一些流量

900
00:44:19,261 --> 00:44:20,580
比如说火星探索月球

901
00:44:20,581 --> 00:44:21,720
探索一些流量

902
00:44:21,721 --> 00:44:27,180
中国航信的是处理一些购买机票查询机票的价格

903
00:44:27,181 --> 00:44:28,830
然后座位的这样一些流量

904
00:44:30,030 --> 00:44:31,260
比较有趣

905
00:44:31,261 --> 00:44:31,740
然后呢

906
00:44:31,741 --> 00:44:33,240
还有一些物联网

907
00:44:33,241 --> 00:44:37,770
比如说欧盟的数字工厂以及像特斯联等等

908
00:44:37,771 --> 00:44:40,110
这样一些物联网的厂商

909
00:44:40,111 --> 00:44:43,800
但也在收银台后面就是一些不同行业和租车

910
00:44:43,801 --> 00:44:44,250
金融

911
00:44:44,251 --> 00:44:47,160
在线教育等等Apisix

912
00:44:47,161 --> 00:44:50,910
其实并不是说适合每一家公司去使用

913
00:44:50,911 --> 00:44:54,750
没有一个项目开源项目是适合所有场景 ApiSix呢

914
00:44:54,751 --> 00:45:03,780
他更适合的是你对高流量以及低延迟有一些比较高的追求或者比较高的

915
00:45:03,781 --> 00:45:05,850
要求的时候他会比较适合

916
00:45:05,851 --> 00:45:07,500
如果你的流量不大

917
00:45:07,501 --> 00:45:09,390
其实你用什么都一样

918
00:45:09,391 --> 00:45:13,590
比如说你用Java的SpringCloud其实也是OK的

919
00:45:13,591 --> 00:45:13,890
对吧

920
00:45:17,940 --> 00:45:18,570
然后呢

921
00:45:18,571 --> 00:45:21,540
这个是Apisix和Kong了

922
00:45:21,541 --> 00:45:26,610
一个对比下这个其实前面已经提到过一些了最大的不同呢

923
00:45:26,611 --> 00:45:32,520
其实就是Apisix是基于ETCD Kong是基于Postgre的

924
00:45:32,521 --> 00:45:35,010
这个是其中一个架构上的不同

925
00:45:35,011 --> 00:45:37,590
后面之所以在性能上会差这么多

926
00:45:37,591 --> 00:45:42,960
更多的是大家在一些细节上面的一些差异

927
00:45:42,961 --> 00:45:46,200
比如说刚才提到的像路由的时间复杂度

928
00:45:46,201 --> 00:45:50,160
IP匹配的时间复杂度等等

929
00:45:50,161 --> 00:45:53,430
这样的一些很细节上的一些点非常多的优化点

930
00:45:53,431 --> 00:45:56,400
最终会造成ApiSix和Kong的性能

931
00:45:56,401 --> 00:45:57,810
会差一个十倍

932
00:45:57,811 --> 00:45:59,760
这样一个最终的效果

933
00:46:05,460 --> 00:46:10,470
然后最后一个就是提下一下Apisix的全流量网关

934
00:46:10,471 --> 00:46:12,600
为什么是全流量了

935
00:46:12,601 --> 00:46:13,350
嗯

936
00:46:13,351 --> 00:46:13,770
这里面

937
00:46:13,771 --> 00:46:19,200
其实就是说现在越来越多的流量不止是跑在

938
00:46:20,220 --> 00:46:21,570
南北向

939
00:46:21,571 --> 00:46:23,670
而很多是在东西向上的

940
00:46:23,671 --> 00:46:25,770
比如说服务之间的流量

941
00:46:25,771 --> 00:46:27,510
那我在东西向流量里面呢

942
00:46:27,511 --> 00:46:28,050
Nginx

943
00:46:28,051 --> 00:46:32,970
很多功能其实已经不太不太适合去把东西向的流量

944
00:46:32,971 --> 00:46:35,670
比如说东西向的流量很多是

945
00:46:35,671 --> 00:46:38,880
你需要都是在啊

946
00:46:38,881 --> 00:46:39,390


947
00:46:39,391 --> 00:46:40,800
RPC的这样的一些流量

948
00:46:40,801 --> 00:46:43,050
或者是通过这种双向认证

949
00:46:43,051 --> 00:46:45,870
然后Nginx 其实已经会比较困难

950
00:46:45,871 --> 00:46:48,540
而且在南北向呢

951
00:46:48,541 --> 00:46:51,150
Nginx也有非常多的这种挑战者

952
00:46:51,151 --> 00:46:53,100
比如说可以用Kong

953
00:46:53,101 --> 00:46:54,870
Apisix直接替代Nginx

954
00:46:54,871 --> 00:46:56,040
因为Kong和Apisix

955
00:46:56,041 --> 00:46:57,990
都是基于Nginx的

956
00:46:57,991 --> 00:46:59,730
所以他可以很轻松的去把

957
00:46:59,731 --> 00:47:02,160
Nginx给替换掉

958
00:47:02,161 --> 00:47:03,660
或者你用Envoy去替代Nginx

959
00:47:04,860 --> 00:47:07,440
或者是你是如果是已经上了云

960
00:47:07,441 --> 00:47:12,690
那么你就更加没不要用Nginx, 你用SLB+Api网关

961
00:47:12,691 --> 00:47:14,280
或者SLB的流量打到K8S Ingress Controller上去

962
00:47:14,281 --> 00:47:15,420


963
00:47:15,421 --> 00:47:16,710
你都可以很轻松的把Nginx替换掉

964
00:47:16,711 --> 00:47:17,550


965
00:47:19,890 --> 00:47:23,220
东西向的流量钱越来越多

966
00:47:23,221 --> 00:47:25,050
像ServiceMesh啊

967
00:47:25,051 --> 00:47:29,340
这种东西也在很多的公司逐步的去落地

968
00:47:29,341 --> 00:47:30,300
ServiceMesh和Api网关呢

969
00:47:30,301 --> 00:47:32,670
其实大家也会去看

970
00:47:32,671 --> 00:47:36,390
觉得有很多功能是一样的

971
00:47:36,391 --> 00:47:39,000
比如说一些身份认证、限流限速啊

972
00:47:39,001 --> 00:47:40,950
路由这种基本是一样

973
00:47:40,951 --> 00:47:43,350
但是他们的位置是不一样的

974
00:47:43,351 --> 00:47:47,370
一个是针对于外部的面对终端客户的

975
00:47:48,630 --> 00:47:49,500
另外一个呢

976
00:47:49,501 --> 00:47:54,720
他是把服务之间的流量给去做一个调度

977
00:47:54,721 --> 00:47:55,620
他们的位置也不一样

978
00:47:55,621 --> 00:47:56,610
而且面积也不一样

979
00:47:58,290 --> 00:47:59,700
并且ServiceMesh、Istio、Envoy

980
00:47:59,701 --> 00:48:00,240


981
00:48:00,241 --> 00:48:03,390
已经成为了一个标准

982
00:48:03,391 --> 00:48:03,900
所以呢

983
00:48:03,901 --> 00:48:08,700
其实大家越来越想做的是另外一件事就是全流量通吃

984
00:48:08,701 --> 00:48:10,980
同时南北向的Api网关

985
00:48:10,981 --> 00:48:12,810
希望去做微服网关

986
00:48:14,370 --> 00:48:16,950
对然后东西上的服务网格呢

987
00:48:16,951 --> 00:48:19,470
想去做南北向的Api网关

988
00:48:20,850 --> 00:48:22,830
比如说Envoy、Kong、ApiSix

989
00:48:22,831 --> 00:48:27,300
甚至虽然大家都是在接入层上去做

990
00:48:27,301 --> 00:48:32,160
但是其实我们大家其实最终想做的都是想做一个全流量的接入层

991
00:48:32,161 --> 00:48:33,360
全流量的意思是说呢

992
00:48:33,361 --> 00:48:36,000
不管你的流量是从客户端来的

993
00:48:36,001 --> 00:48:37,980
还是从IoT设备来的

994
00:48:37,981 --> 00:48:40,080
或者是从服务之间流量来的

995
00:48:40,081 --> 00:48:42,600
或者是K8S Ingress

996
00:48:42,601 --> 00:48:45,450
只要是接入层

997
00:48:45,451 --> 00:48:46,200
Envoy、Kong、ApiSix

998
00:48:46,201 --> 00:48:47,670
甚至都想把它全吃了

999
00:48:49,740 --> 00:48:50,100
同时

1000
00:48:50,101 --> 00:48:54,240
接入层也不再是Nginx和F5的传统功能和领地了

1001
00:48:54,241 --> 00:48:57,390
未来一定是属于开源项目了

1002
00:48:57,391 --> 00:48:57,990
并且呢

1003
00:48:57,991 --> 00:48:59,370
在接入层上的开源项目么

1004
00:48:59,371 --> 00:49:00,750
其实现在是百花齐放

1005
00:49:00,751 --> 00:49:03,030
比如说百度的BFE

1006
00:49:03,031 --> 00:49:10,080
比如说蚂蚁金服的MOSN等等都会尝试在接入层上面去做一些开源的项目

1007
00:49:10,081 --> 00:49:14,910
像传统的F5、深信服等等去做

1008
00:49:14,911 --> 00:49:18,000
用硬件盒子去做接入层

1009
00:49:19,200 --> 00:49:21,690
这种方式能很快就会被完全淘汰的

1010
00:49:23,370 --> 00:49:27,900
然后ApiSix在自己的一些全流量里面是有些自己的计划

1011
00:49:27,901 --> 00:49:33,540
比如说我们之前提到的我们用Nginx是因为Nginx足够的稳定

1012
00:49:33,541 --> 00:49:35,460
而且性能足够的高

1013
00:49:35,461 --> 00:49:37,140
但是他的不好的地方

1014
00:49:37,141 --> 00:49:39,150
我们就把它剥离了

1015
00:49:39,151 --> 00:49:41,580
我们只使用了Nginx的网络库

1016
00:49:41,581 --> 00:49:45,330
但是把他的路由匹配、静态配置和C模块

1017
00:49:45,331 --> 00:49:49,590
完全不要 全部换成我们自己写的这些东西

1018
00:49:50,610 --> 00:49:50,940
同时

1019
00:49:50,941 --> 00:49:54,330
让我们增加了一个独立的控制平面控制

1020
00:49:54,331 --> 00:49:59,700
控制平面的可以调度所有的数据平面 这些数据平面的并不局限于ApiSix

1021
00:49:59,701 --> 00:50:03,090
我们希望可以控制Envoy

1022
00:50:03,091 --> 00:50:03,570
控制Kong

1023
00:50:03,571 --> 00:50:04,350
控制Nginx

1024
00:50:04,351 --> 00:50:05,910
控制所有的数据平面

1025
00:50:07,140 --> 00:50:08,040
同时在数据平台

1026
00:50:08,041 --> 00:50:09,150
然后控制平面之外

1027
00:50:09,151 --> 00:50:11,160
ApiSix增加了AI平面

1028
00:50:11,161 --> 00:50:12,720
我们叫AP

1029
00:50:12,721 --> 00:50:13,710
这是因为呢

1030
00:50:13,711 --> 00:50:16,050
DP和CP其实本身都是没有价值

1031
00:50:17,490 --> 00:50:20,070
就像Nginx一样

1032
00:50:20,071 --> 00:50:23,400
你如果只是一个负责流量转发

1033
00:50:23,401 --> 00:50:24,690
其实你是没有价值的

1034
00:50:24,691 --> 00:50:26,220
你只有分析里面的数据

1035
00:50:26,221 --> 00:50:29,610
比如说为什么Spark、Kafka等等

1036
00:50:29,611 --> 00:50:31,680
这样的一些开源项目

1037
00:50:31,681 --> 00:50:34,500
它给企业带来的价值会更大

1038
00:50:34,501 --> 00:50:37,470
是因为他在分析流动数据所以呢

1039
00:50:37,471 --> 00:50:40,560
你如果网关层面没有分析数据

1040
00:50:40,561 --> 00:50:44,040
那么其实你对用户的业务价值并并不算大

1041
00:50:44,041 --> 00:50:45,870
你只有反哺业务才会有价值

1042
00:50:46,830 --> 00:50:49,860
在DP、AP、CP的整个过程当中

1043
00:50:49,861 --> 00:50:51,870
我们希望的是呢

1044
00:50:51,871 --> 00:50:55,530
不止是开发者能够参与进来

1045
00:50:55,531 --> 00:50:58,170
而且奥布斯、PM等等

1046
00:50:58,171 --> 00:51:04,050
这些所有的和流量相关的和用户业务相关的人员都可以参与进来

1047
00:51:04,051 --> 00:51:06,330
所以ApiSix也会去推他低代码的

1048
00:51:06,331 --> 00:51:09,000
功能 低代码不只是在DP

1049
00:51:09,001 --> 00:51:10,410
我们后面在CP、AP上面都会加低代码

1050
00:51:10,411 --> 00:51:16,110
是希望能够让所有的人都能够参与进来

1051
00:51:18,630 --> 00:51:19,500
然后最后呢

1052
00:51:19,501 --> 00:51:26,670
我花一点时间去介绍一下ApiSix的开源之路和我们社区的规划 ApiSix呢

1053
00:51:26,671 --> 00:51:29,640
被Apache的孵化器的主席

1054
00:51:29,641 --> 00:51:31,530
和我们的champion的评价都是一样的

1055
00:51:31,531 --> 00:51:32,760
你的评价都是一样的

1056
00:51:32,761 --> 00:51:34,710
就是ApiSix是最省心的

1057
00:51:34,711 --> 00:51:35,730
Apache孵化器项目

1058
00:51:37,080 --> 00:51:39,210
我们会每个月发布一个版本

1059
00:51:40,380 --> 00:51:46,110
这个其实是从ApiSix从去年六月份开始到现在一个雷打不动一个规则

1060
00:51:46,111 --> 00:51:47,610
我们每个月一个版本

1061
00:51:47,611 --> 00:51:51,000
这个的就会让社区和用户保持一个习惯

1062
00:51:51,001 --> 00:51:51,810
比如说我们这个月

1063
00:51:51,811 --> 00:51:53,370
如果发版本时间晚了一会

1064
00:51:53,371 --> 00:51:53,850
不就会说

1065
00:51:53,851 --> 00:51:54,030
哎

1066
00:51:54,031 --> 00:51:55,770
你们怎么还没有发版本

1067
00:51:55,771 --> 00:51:56,760
用户会有一个预期

1068
00:51:57,840 --> 00:52:00,540
我这个版本遇到的bug下个版本就会被修复掉

1069
00:52:01,590 --> 00:52:05,400
这个对于开源项目来说特别的重要

1070
00:52:05,401 --> 00:52:06,810
比如说有一些开源项目

1071
00:52:06,811 --> 00:52:09,240
可能一年发一个会发两个版本

1072
00:52:09,241 --> 00:52:13,230
我们觉得一年发一两个版本的开源项目其实就已经死掉了

1073
00:52:14,940 --> 00:52:17,250
特别是像在云原生了这个时代

1074
00:52:17,251 --> 00:52:20,550
开源项目这种百花齐放的时代

1075
00:52:20,551 --> 00:52:25,050
你如果没有把保持一两个月一个版本

1076
00:52:25,051 --> 00:52:29,670
其实已经绝对跟不上用户的节奏了

1077
00:52:29,671 --> 00:52:30,180
然后呢

1078
00:52:30,181 --> 00:52:33,870
还有一个比较重要的是我们会对用户的反馈做到当天的回复

1079
00:52:33,871 --> 00:52:35,790
比如说我们当天会回邮件列表

1080
00:52:35,791 --> 00:52:38,220
会回给他的ISSUE、PR

1081
00:52:38,221 --> 00:52:41,790
同时那我会我们也会去频繁的布道和走访用户

1082
00:52:41,791 --> 00:52:49,260
比如说我们在疫情之前每个月会有一次线下的meetup 同时我们也走访了非常多的公司 走访这些公司呢

1083
00:52:49,261 --> 00:52:52,110
其实布道是一个方面 另外一个方面的

1084
00:52:52,111 --> 00:52:52,290
其实

1085
00:52:52,291 --> 00:52:59,280
我们从这些公司的使用场景以及他的一些未来的一些规划

1086
00:52:59,281 --> 00:53:00,810
就我们可以看到

1087
00:53:00,811 --> 00:53:06,030
在接入层在Api网关这个层面大家的一些思考和选择到底是什么样子的

1088
00:53:07,470 --> 00:53:07,890
不然的话

1089
00:53:07,891 --> 00:53:09,480
我们可能就是在闭门造车

1090
00:53:12,480 --> 00:53:14,970
然后对开源项目来说呢

1091
00:53:14,971 --> 00:53:16,260
很多人会说我一看项目

1092
00:53:16,261 --> 00:53:17,910
我们看哪些指标

1093
00:53:17,911 --> 00:53:20,220
有些人会看过他的Github的Star数

1094
00:53:20,221 --> 00:53:22,440
这是一个非常常见的

1095
00:53:22,441 --> 00:53:25,080
这样的一个

1096
00:53:25,081 --> 00:53:27,060
这样的一种考核的指标

1097
00:53:27,061 --> 00:53:29,460
所以很多的开源项目呢

1098
00:53:29,461 --> 00:53:31,350
都会说我的Stars数是有多高

1099
00:53:31,351 --> 00:53:34,560
甚至有很多开源项目是刷Star

1100
00:53:34,561 --> 00:53:35,850
那么ApiSix是

1101
00:53:35,851 --> 00:53:37,950
从来不看Github的Star数的

1102
00:53:37,951 --> 00:53:44,130
而且我们也从来不去 不去觉得用户我们的Star数高就怎么样

1103
00:53:44,131 --> 00:53:46,980
其实我们觉得这个完全是没有关系的

1104
00:53:46,981 --> 00:53:48,570
对于看着项目来说呢

1105
00:53:49,770 --> 00:53:51,480
真正重要的是两点

1106
00:53:51,481 --> 00:53:56,550
第一点是怎么能够吸引全球顶级的开发者

1107
00:53:57,780 --> 00:54:04,050
知道你这个项目第二点就是怎么让他们变成你的代码贡献者要知道

1108
00:54:05,070 --> 00:54:10,620
大部分的开发者水平其实都是

1109
00:54:10,621 --> 00:54:11,670
也就是说换一种说法

1110
00:54:11,671 --> 00:54:15,660
就是说全球顶级的开发者的资源是非常稀少的

1111
00:54:15,661 --> 00:54:17,280
而且他们的精力很有限

1112
00:54:17,281 --> 00:54:20,520
我们怎么能够吸引全球最顶级的开发者

1113
00:54:20,521 --> 00:54:21,960
并且还能保持活跃

1114
00:54:21,961 --> 00:54:23,220
这个是我们唯一的目标

1115
00:54:25,200 --> 00:54:25,710
然后呢

1116
00:54:25,711 --> 00:54:26,970
贡献不只是代码

1117
00:54:26,971 --> 00:54:28,500
像文档测试啊

1118
00:54:28,501 --> 00:54:29,820
写文章都是贡献

1119
00:54:29,821 --> 00:54:31,770
然后我们现在有一些committer和PMC

1120
00:54:31,771 --> 00:54:33,600
也主要是比如说写文档

1121
00:54:33,601 --> 00:54:35,670
写测试、写文章都是OK的

1122
00:54:35,671 --> 00:54:41,190
而且并没有说写代码的就比写文档的要牛 地位就要高

1123
00:54:41,191 --> 00:54:41,940
其实都是没有的

1124
00:54:43,050 --> 00:54:43,980
然后呢

1125
00:54:43,981 --> 00:54:45,990
多样性也是我们会考虑的一个点

1126
00:54:45,991 --> 00:54:49,260
比如说我们的近三十位committer

1127
00:54:49,261 --> 00:54:51,240
其中有两个欧洲的开发者

1128
00:54:51,241 --> 00:54:51,720
然后呢

1129
00:54:51,721 --> 00:54:53,910
至少有四位是大学生

1130
00:54:53,911 --> 00:54:55,560
这样在我们讨论问题的时候呢

1131
00:54:55,561 --> 00:54:57,960
其实你的角度就会更多一些

1132
00:54:57,961 --> 00:55:00,150
而不只是大家的背景是一样的

1133
00:55:00,151 --> 00:55:02,250
这个其实就会很容易让开源项目走偏

1134
00:55:03,870 --> 00:55:04,230
然后呢

1135
00:55:04,231 --> 00:55:07,050
我们也有零零后的ApiSix committer

1136
00:55:10,080 --> 00:55:19,140
额这个是我们觉得比较重要的另外一个点就是Apache The Apache Way

1137
00:55:19,141 --> 00:55:23,520
总结成一句就是社区大于代码举个例子

1138
00:55:23,521 --> 00:55:25,440
就是说一个活跃的社区

1139
00:55:26,640 --> 00:55:27,480
是最重要的

1140
00:55:27,481 --> 00:55:29,460
就算你的代码写的非常的烂

1141
00:55:29,461 --> 00:55:31,470
但是只要这个社区活跃

1142
00:55:31,471 --> 00:55:34,230
那么烂的代码就会被重构了

1143
00:55:34,231 --> 00:55:36,690
但是如果你的代码写的非常的好

1144
00:55:36,691 --> 00:55:37,200
就像Nginx一样

1145
00:55:37,201 --> 00:55:39,180
代码写的非常的好

1146
00:55:39,181 --> 00:55:40,680
但是社区不活跃

1147
00:55:42,150 --> 00:55:43,710
也是没有用

1148
00:55:43,711 --> 00:55:44,910
然后比如说ApiSix

1149
00:55:44,911 --> 00:55:47,340
ApiSix Dashboard重构

1150
00:55:47,341 --> 00:55:49,110


1151
00:55:49,111 --> 00:55:51,930
社区对于这个重构方案是非常不满意的

1152
00:55:51,931 --> 00:55:53,550
经常会吐槽

1153
00:55:53,551 --> 00:55:54,450
但是呢

1154
00:55:54,451 --> 00:55:55,320
吐槽归吐槽

1155
00:55:55,321 --> 00:55:58,380
但是大家觉得这个项目还是比较有用的

1156
00:55:58,381 --> 00:56:01,230
所以呢就有来自于五家不同公司的贡献者

1157
00:56:01,231 --> 00:56:02,940
我们正在把他给重构了

1158
00:56:02,941 --> 00:56:05,850
我们希望在十一前后就会有一个全新的

1159
00:56:07,800 --> 00:56:10,200
但是Dashboard这样的一个新的方案

1160
00:56:10,201 --> 00:56:11,820
所以说呢

1161
00:56:11,821 --> 00:56:17,130
一个活跃的社区会把你的烂代码都重构掉 你的项目会变得越来越好

1162
00:56:19,140 --> 00:56:19,590
然后

1163
00:56:19,591 --> 00:56:20,970
这是一篇ApiSix的规划

1164
00:56:20,971 --> 00:56:24,570
我们会在下周发布二点零的版本

1165
00:56:24,571 --> 00:56:25,950
二点零的版本

1166
00:56:25,951 --> 00:56:29,610
里面的我们会用ETCD V3的协议替代掉V2的协议

1167
00:56:29,611 --> 00:56:31,110
然后在三点零的版本里面呢

1168
00:56:31,111 --> 00:56:35,490
我们我们会把现在admin的api全部废弃的

1169
00:56:35,491 --> 00:56:38,520
然后会把DP和CP完全的分离开

1170
00:56:39,990 --> 00:56:41,640
然后2021年

1171
00:56:41,641 --> 00:56:45,210
我们的flag就是贡献者超过两百位

1172
00:56:45,211 --> 00:56:48,570
现在是110多位

1173
00:56:48,571 --> 00:56:52,830
我们在去年十月份进入帕奇的时候只有二十位代码贡献者

1174
00:56:53,760 --> 00:56:55,440
然后我们用了九个月的时间

1175
00:56:55,441 --> 00:56:58,350
从二十位到了110位

1176
00:56:58,351 --> 00:57:02,310
但我们希望明年我们可以超过两百位代码贡献者

1177
00:57:02,311 --> 00:57:06,630
然后作为ApiSix的PMC和VP

1178
00:57:06,631 --> 00:57:10,110
我们我最重要的一个任务就是

1179
00:57:11,070 --> 00:57:14,520
给ApiSix带来更多的代码贡献者

1180
00:57:15,510 --> 00:57:17,730
或者是其他的文档测试贡献者

1181
00:57:17,731 --> 00:57:18,360
所以呢

1182
00:57:18,361 --> 00:57:21,450
最后我希望大家能够给ApiSix去做贡献

1183
00:57:22,440 --> 00:57:25,290
OK然后看大家有什么问题

1184
00:57:31,020 --> 00:57:32,160
哎

1185
00:57:32,161 --> 00:57:34,920
那个感谢wenming老师的分享

1186
00:57:34,921 --> 00:57:38,850
然后就是说我们是这样的

1187
00:57:38,851 --> 00:57:44,070
就是我们有一个问就是收集问题的文档

1188
00:57:44,071 --> 00:57:47,610
然后不知道为啥老是你就知道我发你一下

1189
00:57:48,600 --> 00:57:49,320
那好

1190
00:57:49,321 --> 00:57:50,310
你是怎么发给我

1191
00:57:51,600 --> 00:57:52,170
这位亲

1192
00:57:53,190 --> 00:57:55,020
微信吧OK

1193
00:57:56,580 --> 00:57:58,410
会议云会议了也会有疤

1194
00:57:58,411 --> 00:58:02,190
会议里面发挥也没什么都行

1195
00:58:02,191 --> 00:58:04,290
好像我切出来就会断直播的吗

1196
00:58:07,290 --> 00:58:08,940
应该还好

1197
00:58:08,941 --> 00:58:10,470
应该还在进行中

1198
00:58:15,810 --> 00:58:16,860
我等抓进去

1199
00:58:24,480 --> 00:58:27,720
我这么多问题

1200
00:58:27,721 --> 00:58:30,930
然后我这边先向刷碗

1201
00:58:30,931 --> 00:58:33,870
然后因为是这样的

1202
00:58:33,871 --> 00:58:37,800
就是说明老师你切到那个下面的抽奖吗

1203
00:58:37,801 --> 00:58:40,560
因为我还需要再提醒一下大家去抽奖

1204
00:58:40,561 --> 00:58:41,310
因为我发现

1205
00:58:42,480 --> 00:58:43,440
提问的人很多

1206
00:58:43,441 --> 00:58:47,490
而且抽奖的人就是就是帮派的人很多

1207
00:58:47,491 --> 00:58:50,310
但是大家好像没有用了一个福利

1208
00:58:50,311 --> 00:58:54,510
就是说这是我们文明老师带几个时间的一门

1209
00:58:54,511 --> 00:58:57,960
非常好的课程就是OpenResty从入门到实战

1210
00:58:57,961 --> 00:59:03,660
然后我们今天晚上会就是抽五名幸运观众

1211
00:59:03,661 --> 00:59:06,000
然后直接扫这个二维码就可以参与抽奖

1212
00:59:08,280 --> 00:59:09,900
然后

1213
00:59:09,901 --> 00:59:10,740
整体上就这样

1214
00:59:10,741 --> 00:59:12,480
然后等等会

1215
00:59:12,481 --> 00:59:15,870
我们也会在切换到这个抽奖页面

1216
00:59:15,871 --> 00:59:21,960
那么接下来会先就是继续让我们的wenming老师解答一下这个大家的一些疑惑

1217
00:59:25,230 --> 00:59:27,480
OK我就一个一个来吧

1218
00:59:27,481 --> 00:59:33,540
1. APISIX和SpringCloudGateway&Zuul有什么区别和联系？

1219
00:59:33,541 --> 00:59:35,040
那个主席

1220
00:59:35,041 --> 00:59:40,290
你这边是不是指就是指共享的那个PPT是不是还得重新共享一下

1221
00:59:40,291 --> 00:59:42,840
就是我这边看到的应该是黑屏 稍等

1222
00:59:49,890 --> 00:59:50,340
现在呢

1223
00:59:54,900 --> 00:59:55,680
哈喽

1224
00:59:56,760 --> 01:00:00,540
没带可以了

1225
01:00:00,541 --> 01:00:01,740
能看到吗

1226
01:00:01,741 --> 01:00:02,370
对了对了

1227
01:00:02,371 --> 01:00:02,790


1228
01:00:07,950 --> 01:00:10,260
OK然后我们一个一个来看一下吧

1229
01:00:10,261 --> 01:00:13,830
1. APISIX和SpringCloudGateway&Zuul有什么区别和联系？

1230
01:00:13,831 --> 01:00:16,350
其实他们之间

1231
01:00:16,351 --> 01:00:17,130
没什么联系

1232
01:00:17,131 --> 01:00:19,110
他们的定位其实都是一样的

1233
01:00:19,111 --> 01:00:21,870
就是去做一个网关

1234
01:00:21,871 --> 01:00:23,880
然后区别的话其实有几个方面

1235
01:00:23,881 --> 01:00:32,130
第一个, 从开发语言上来说, SpringCluodGateway、Zuul都是用Java开发的, ApiSix是用lua开发的

1236
01:00:33,060 --> 01:00:36,000
从功能上来说呢

1237
01:00:36,001 --> 01:00:40,590
SpringCloudGateway和Zuul的功能会比较少

1238
01:00:40,591 --> 01:00:41,880


1239
01:00:41,881 --> 01:00:42,840
没有ApiSix功能那么多

1240
01:00:42,841 --> 01:00:43,860


1241
01:00:43,861 --> 01:00:45,480
ApiSix在插件上就有四十多个插件

1242
01:00:45,481 --> 01:00:46,020
功能覆盖

1243
01:00:46,021 --> 01:00:47,160
会更全一些

1244
01:00:47,161 --> 01:00:48,420
然后从性能上来说了

1245
01:00:48,421 --> 01:00:50,400
我们之前有一家用户

1246
01:00:50,401 --> 01:00:53,820
他去做过类似的性能测试

1247
01:00:53,821 --> 01:00:57,060
SpringCloudGateway和ApiSix的性能

1248
01:00:57,061 --> 01:01:01,440
加上他们的业务之后大概是一个十倍左右的一个性能的一个差异

1249
01:01:02,400 --> 01:01:05,640
对但是如果你是自己的开发

1250
01:01:05,641 --> 01:01:07,380
如果完全都是java系

1251
01:01:07,381 --> 01:01:08,910
并且流量不大

1252
01:01:08,911 --> 01:01:12,030
那么其实对你来说就没什么区别

1253
01:01:12,031 --> 01:01:13,470
如果你的流量比较大

1254
01:01:13,471 --> 01:01:17,070
那么它的性能上的差异会非常的明显

1255
01:01:17,071 --> 01:01:19,620
我们有一些已经在线上跑的用户

1256
01:01:19,621 --> 01:01:21,360
它的性能差别是十倍

1257
01:01:21,361 --> 01:01:23,550
他已经从SpringCloudGateway迁到ApiSix

1258
01:01:25,380 --> 01:01:28,740
Apache APISIX 与 Nginx 的异同？

1259
01:01:28,741 --> 01:01:33,000
这个其实我们刚才已经提到了ApiSix

1260
01:01:33,001 --> 01:01:37,470
只用了Nginx的底层的网络库

1261
01:01:37,471 --> 01:01:38,010
但是呢

1262
01:01:38,011 --> 01:01:39,990
他并没有使用

1263
01:01:39,991 --> 01:01:47,010
Nginx他的一些路由、他的一些静态配置文件、他的一些外部的C模块

1264
01:01:47,011 --> 01:01:48,810
这些都没有用

1265
01:01:48,811 --> 01:01:52,260
是因为我们觉得Nginx底层足够的优秀

1266
01:01:52,261 --> 01:01:52,770
但是呢

1267
01:01:52,771 --> 01:01:56,220
我们希望在他优秀的上面去加一些动态的能力

1268
01:01:57,180 --> 01:01:59,160
然后从Nginx迁到ApiSix呢

1269
01:02:00,180 --> 01:02:04,590
我们现在还没有完全自动迁移的这样的一个工具

1270
01:02:04,591 --> 01:02:05,400
现在还没有

1271
01:02:06,630 --> 01:02:08,310
恩现在迁移的话就是

1272
01:02:08,311 --> 01:02:12,150
如果你的Nginx来处理API的数量不多的话呢

1273
01:02:12,151 --> 01:02:14,430
你可以手动的来迁

1274
01:02:14,431 --> 01:02:18,150
如果你在Nginx里面处理了一些静态的文件

1275
01:02:18,151 --> 01:02:24,840
比如说一些Proxy Cache 看起来或者是一些处理一些静态资源

1276
01:02:24,841 --> 01:02:26,940
而不是Api的流量的话

1277
01:02:26,941 --> 01:02:31,710
你就需要自己在ApiSix的代码上面做了一些修改

1278
01:02:31,711 --> 01:02:35,670
去把Nginx的配置嵌入在ApiSix里面才可以

1279
01:02:35,671 --> 01:02:39,720
对现在其实还没有一个很简单的自动迁移的工具

1280
01:02:39,721 --> 01:02:43,050
还没有然后欢迎大家来做贡献

1281
01:02:43,051 --> 01:02:44,310
其实这个还是挺有用的

1282
01:02:47,880 --> 01:02:49,380
然后第三个是动态证书

1283
01:02:49,381 --> 01:02:51,630
是什么动态证书是这样的

1284
01:02:51,631 --> 01:02:52,410
就是我

1285
01:02:52,411 --> 01:02:55,530
我们现在的很多流量其实都是

1286
01:02:55,531 --> 01:02:56,010


1287
01:02:56,011 --> 01:02:58,080
HTTPS流量对吧

1288
01:02:58,081 --> 01:02:59,040
HTTPS流量了

1289
01:02:59,041 --> 01:03:06,000
我网关上很重要的一个功能就是这种流量的这种卸载我需要把

1290
01:03:06,001 --> 01:03:06,840
HTTPS

1291
01:03:06,841 --> 01:03:08,100
让我给卸载了

1292
01:03:08,101 --> 01:03:10,860
变成HTTP流量扔给后端的服务

1293
01:03:10,861 --> 01:03:15,540
那么SSL证书做的就是这个事 为什么要做成动态的

1294
01:03:15,541 --> 01:03:18,900
现在的SSL证书的有效时间会越来越短

1295
01:03:18,901 --> 01:03:25,440
比如说现在你去购买的一个付费的还是要证书的时间应该是在一年然后呢

1296
01:03:25,441 --> 01:03:28,500
你如果是用

1297
01:03:28,501 --> 01:03:31,710
L1这种一些免费的证书呢

1298
01:03:31,711 --> 01:03:34,770
他的过期时间可能就是三个月

1299
01:03:34,771 --> 01:03:35,250
所以呢

1300
01:03:35,251 --> 01:03:36,030
你需要

1301
01:03:36,031 --> 01:03:38,430
而且你的域名如果比较多

1302
01:03:39,450 --> 01:03:43,170
那么你要频繁变更的证书就会比较多

1303
01:03:43,171 --> 01:03:43,830
另外一方面

1304
01:03:43,831 --> 01:03:45,600
如果你是一个公有云的厂商

1305
01:03:45,601 --> 01:03:48,960
比如说你做的是一个CDN的服务

1306
01:03:48,961 --> 01:03:52,530
那么你可能要管理用户非常多的证书

1307
01:03:52,531 --> 01:03:55,440
可能每个小时证书都有变化

1308
01:03:55,441 --> 01:03:58,050
所以我们需要有一个动态的证书

1309
01:03:58,051 --> 01:04:01,110
主要是来解决这种HTTPS流量卸载的问题

1310
01:04:01,111 --> 01:04:02,010


1311
01:04:05,610 --> 01:04:06,330


1312
01:04:06,331 --> 01:04:10,350
APISIX 实现微服务东西向、南北向流量的方案, 比如微服务基于 Spring Cloud 

1313
01:04:11,340 --> 01:04:11,760
嗯

1314
01:04:11,761 --> 01:04:15,060
其实我们ApiSix里面能去做这种南北向、东西向

1315
01:04:15,061 --> 01:04:18,120
流量里面有个很重要的一个点

1316
01:04:18,121 --> 01:04:20,730
而且我们并没有基于SpringCloud框架去做

1317
01:04:20,731 --> 01:04:26,280
但是我们会把更多的这种服务注册和服务发现的组件给接入进来

1318
01:04:26,281 --> 01:04:32,220
比如说我们除了支持ETCD之外, 还支持Consul、Eureka等等

1319
01:04:32,221 --> 01:04:39,210
这样的一些经常大家经常使用这种服务注册服务发现的这种开源的项目

1320
01:04:39,211 --> 01:04:40,230
并且呢

1321
01:04:40,231 --> 01:04:42,360
我们正在做的一个功能

1322
01:04:42,361 --> 01:04:48,270
就是说我在不同的路由上面我们会支持不同的服务发现的组件

1323
01:04:48,271 --> 01:04:52,110
这样的对于一些新老系统的迁移会非常的有好处

1324
01:04:52,111 --> 01:04:55,710
比如说我的URI是A那么在这个上面呢

1325
01:04:55,711 --> 01:04:57,840
它里面所有的服务的发现

1326
01:04:57,841 --> 01:05:00,360
他可能都是通过ETCD

1327
01:05:00,361 --> 01:05:00,870
然后呢

1328
01:05:00,871 --> 01:05:04,050
通过另外一个URI进来的

1329
01:05:04,051 --> 01:05:04,560
我的所有的服务发现都是Consul

1330
01:05:04,561 --> 01:05:06,510


1331
01:05:06,511 --> 01:05:08,700
然后在另外一个可能走的是

1332
01:05:11,970 --> 01:05:14,100
Nacos等等 可能不一样

1333
01:05:14,101 --> 01:05:15,270
这个做了之后呢

1334
01:05:15,271 --> 01:05:19,470
我们就会把这种微服务的处理就会更好一些

1335
01:05:19,471 --> 01:05:20,310
所以基本来说

1336
01:05:20,311 --> 01:05:22,680
我们和SpringCloud的是没有太大关系

1337
01:05:25,170 --> 01:05:25,650
然后呢

1338
01:05:25,651 --> 01:05:29,100
5. Apache APISIX 基于 Nginx/Openresty ，后续是否有维护底层组件计划呢？Apache APISIX 是否考虑后续迁移到 Envoy 平台上？

1339
01:05:29,101 --> 01:05:34,110


1340
01:05:34,111 --> 01:05:35,940
这个其实是一个很好的问题啊

1341
01:05:35,941 --> 01:05:39,240
因为我刚才提到的Nginx和OpenResty

1342
01:05:39,241 --> 01:05:43,830
现在的维护其实已经比较的慢

1343
01:05:43,831 --> 01:05:46,410
比如说一年发两个版本之类的

1344
01:05:46,411 --> 01:05:49,890
其实更新的频率会比较慢

1345
01:05:49,891 --> 01:05:51,420
然后呢

1346
01:05:51,421 --> 01:05:54,120
我们现在了还没有维护底层组件的计划

1347
01:05:54,121 --> 01:05:57,840
因为我们现在还没有足够的人手去维护

1348
01:05:57,841 --> 01:06:01,740
但是我们确实有后续会有维护底层组件了一个计划

1349
01:06:01,741 --> 01:06:06,450
因为我们也比较担心F5收购了Nginx之后

1350
01:06:06,451 --> 01:06:09,060
他的更新的速度在变慢

1351
01:06:09,061 --> 01:06:12,060
而且Nginx自己对云原生啊

1352
01:06:12,061 --> 01:06:13,680
对于微服务

1353
01:06:13,681 --> 01:06:18,330
比如还有一些RPC协议的一些这种代理和协议的转换

1354
01:06:18,331 --> 01:06:20,850
其实他也做得不够好

1355
01:06:20,851 --> 01:06:28,950
我们还是希望能够去把Nginx是底层的和最核心的能力给他剥离出来

1356
01:06:28,951 --> 01:06:34,980
然后Nginx变得更加的适合Api网关的这样的一个方向

1357
01:06:34,981 --> 01:06:36,870
所以我们后续可能会有

1358
01:06:36,871 --> 01:06:38,010
但是现在还没有精力

1359
01:06:40,260 --> 01:06:43,410
APISIX 是否考虑后续迁移到 Envoy 平台上

1360
01:06:43,411 --> 01:06:44,880
这个现在还没有考虑

1361
01:06:44,881 --> 01:06:50,220
因为我们觉得Envoy整体来说我们去掌握

1362
01:06:50,221 --> 01:06:54,210
然后在上面做开发的难度还是比较大的

1363
01:06:54,211 --> 01:06:57,720
因为Envoy现在虽然他的代码贡献者比较多

1364
01:06:57,721 --> 01:07:00,420
但是她毕竟是C++开发了

1365
01:07:00,421 --> 01:07:09,240
然后我们觉得我们现在还没有足够的能力去在Envoy上去做这种很深的开发

1366
01:07:09,241 --> 01:07:11,430
而且Envoy的定位呢

1367
01:07:11,431 --> 01:07:14,130
和ApiSix也不太一样

1368
01:07:14,131 --> 01:07:17,460
而Envoy的定位更多是跑在K8S里面

1369
01:07:17,461 --> 01:07:22,140
跑在容器里对因为Envoy其实是一个一般

1370
01:07:22,141 --> 01:07:25,350
大家都是用这种多线程的方式去跑

1371
01:07:25,351 --> 01:07:28,680
就比如说一个他就跑在一个核上面

1372
01:07:28,681 --> 01:07:29,130
但是呢

1373
01:07:29,131 --> 01:07:30,990
对于API网关来说呢

1374
01:07:30,991 --> 01:07:34,650
他其实是要利用到多核的那种能力了

1375
01:07:34,651 --> 01:07:35,670
所以像Nginx

1376
01:07:35,671 --> 01:07:37,080
他其实是一个多进程的

1377
01:07:37,081 --> 01:07:37,920
这样的一种方式

1378
01:07:38,910 --> 01:07:45,150
但是我们也希望能够和Envoy去做一些更多的一些事情吧

1379
01:07:45,151 --> 01:07:48,600
比如说我们可以在我们的CP平面上去控制Envoy

1380
01:07:48,601 --> 01:07:50,310
我觉得就是一个挺好的事

1381
01:07:53,520 --> 01:07:54,210
然后第六个(APISIX后续有对接注册中心的计划么，当前作为对接K8S集群的api-ingres后续有计划集成到一起么)

1382
01:07:54,211 --> 01:07:57,540
其实我们我刚才回答第四个数已经说到了

1383
01:07:57,541 --> 01:08:01,950
我们已经可以对接很多的注册中心了

1384
01:08:01,951 --> 01:08:03,630
但是我们现在正在做的事呢

1385
01:08:03,631 --> 01:08:05,100
我们可以不同的路

1386
01:08:05,101 --> 01:08:07,290
由对接不同的注册中心

1387
01:08:07,291 --> 01:08:08,580
这个是我们正在做的

1388
01:08:10,860 --> 01:08:13,740
然后当前作为对接K8S Api Ingress

1389
01:08:13,741 --> 01:08:16,530
后续有计划集成到一起么

1390
01:08:16,531 --> 01:08:20,820
而我们现在有一个开源项目是ApiSix的

1391
01:08:20,821 --> 01:08:24,660
Ingress Controller已经有了这样一个项目

1392
01:08:24,661 --> 01:08:28,800
我们也希望能够和官方的 K8S官方的

1393
01:08:28,801 --> 01:08:29,940
应该是K8S Ingress Controller

1394
01:08:29,941 --> 01:08:32,280
去做一些配合

1395
01:08:32,281 --> 01:08:36,090
然后这个现在还没有一个很详细的一个计划

1396
01:08:39,060 --> 01:08:46,410
然后插件的安全性如何保证一个死循环会不会导致网关不可用 这个其实是会有这个问题

1397
01:08:46,411 --> 01:08:51,930
特别是你用户自己写的一个插件

1398
01:08:51,931 --> 01:08:57,240
官方写的插件的其实已经在代码上去做了一些review和保证

1399
01:08:57,241 --> 01:08:59,790
一般来说还是比较稳定的

1400
01:08:59,791 --> 01:09:03,000
但是对于一个用户自己写的插件来说呢

1401
01:09:03,001 --> 01:09:05,100
很可能会有死循环

1402
01:09:06,660 --> 01:09:07,500
如果死循环了

1403
01:09:07,501 --> 01:09:11,070
就会导致整个网关的CPU可能会跑满

1404
01:09:11,071 --> 01:09:14,010
这个确实是坑 会存在这个问题

1405
01:09:14,011 --> 01:09:19,380
现在ApiSix并没有对插件做一些隔离或者资源上的控制

1406
01:09:19,381 --> 01:09:20,310
这个现在还没有

1407
01:09:20,311 --> 01:09:23,640
所以这个会是一个潜在的问题

1408
01:09:23,641 --> 01:09:26,190
而且这个问题是要用户自己去保障

1409
01:09:26,191 --> 01:09:28,860
所以我们希望用户在自己写插件的时候呢

1410
01:09:28,861 --> 01:09:31,320
会去做更多的测试案例

1411
01:09:34,050 --> 01:09:35,100
Apache APISIX 如何注入故障

1412
01:09:35,101 --> 01:09:38,820


1413
01:09:38,821 --> 01:09:42,000
ApiSix有一个故障注入的一个插件

1414
01:09:42,001 --> 01:09:44,670
对这里故障注入的功能呢

1415
01:09:44,671 --> 01:09:46,980
是我们可以是我们可以在Etcd里面 不是

1416
01:09:46,981 --> 01:09:54,750
我们可以在ApiSix的插件里面去模拟上游的各种故障以及他的一些返回值

1417
01:09:54,751 --> 01:10:03,090
比如说我可以让用户自己去做一个Http的response code

1418
01:10:03,091 --> 01:10:05,880
或者response body

1419
01:10:05,881 --> 01:10:08,670
而且可以在模拟下上游的响应时间

1420
01:10:08,671 --> 01:10:12,450
比如说我这个上个上游可能是一秒或者两秒

1421
01:10:12,451 --> 01:10:15,780
这样的一个处理时间

1422
01:10:15,781 --> 01:10:17,160
这些都是可以模拟的

1423
01:10:17,161 --> 01:10:19,290
所以我们通过这种方式去做故障注入

1424
01:10:19,291 --> 01:10:21,870
他其实是一个用Lua写的一个插件

1425
01:10:23,430 --> 01:10:24,960
apisix 适合做流量网关还是业务网关

1426
01:10:24,961 --> 01:10:26,430


1427
01:10:26,431 --> 01:10:26,850
ApiSix

1428
01:10:26,851 --> 01:10:28,260
是一个Api网关

1429
01:10:28,261 --> 01:10:28,920
所以呢

1430
01:10:28,921 --> 01:10:30,240
他处理的是业务的流量

1431
01:10:30,241 --> 01:10:34,680
我们一般不太建议用户在网关上面去写自己的业务

1432
01:10:34,681 --> 01:10:35,070
所以呢

1433
01:10:35,071 --> 01:10:35,970
从字面上来说呢

1434
01:10:35,971 --> 01:10:40,590
写了一篇甚至更适合的去做流量的处理

1435
01:10:40,591 --> 01:10:41,310
业务上了

1436
01:10:41,311 --> 01:10:46,950
我们还是希望大家把一些公共的这样的一些功能放在网关层面

1437
01:10:46,951 --> 01:10:49,920
而不要把业务的功能放在网关层面

1438
01:10:51,510 --> 01:10:55,080
第十个还我们现在还没有这样的官方实践的文档

1439
01:10:55,081 --> 01:10:58,860
我记得lihui有一个开源项目

1440
01:10:58,861 --> 01:11:00,750
但是现在好像还没有

1441
01:11:02,250 --> 01:11:03,810
做的很完善OK

1442
01:11:03,811 --> 01:11:06,330
其实大家可以一起来去做贡献

1443
01:11:06,331 --> 01:11:11,100
比如说大家可以开一个ISSUE或者开一个开源项目

1444
01:11:11,101 --> 01:11:15,690
然后大家一起去往上面去补充 像OpenResty最佳实践

1445
01:11:15,691 --> 01:11:23,820
其实最开始也是用这种方式逐步的把这些一些第三方实践的一些常见的问题慢慢给补充起来

1446
01:11:23,821 --> 01:11:30,270
所以我还是挺希望大家能够用这种开源协作的方式去做一些这样的官方实践的文档

1447
01:11:32,460 --> 01:11:33,810
然后ApiSix作为开源项目

1448
01:11:33,811 --> 01:11:35,880
没有看到企业版如何盈利

1449
01:11:35,881 --> 01:11:38,010
是这样子的ApiSix呢

1450
01:11:38,011 --> 01:11:41,400
你我们现在从开源项目来说了

1451
01:11:41,401 --> 01:11:43,290
但有三种赢利的方式

1452
01:11:43,291 --> 01:11:44,640
上面有三种赢利的方式

1453
01:11:44,641 --> 01:11:47,370
第一种是商业支持

1454
01:11:47,371 --> 01:11:48,030
也就是说

1455
01:11:48,031 --> 01:11:51,990
某一家公司使用了ApiSix的开源版本

1456
01:11:51,991 --> 01:11:52,890
但是呢

1457
01:11:52,891 --> 01:11:55,590
还觉得如果我在线上遇到了一个bug

1458
01:11:55,591 --> 01:11:57,570
或者遇到了一些故障

1459
01:11:57,571 --> 01:12:02,010
或者是说他希望ApiSix只能够增加某些功能

1460
01:12:02,011 --> 01:12:02,520
但是呢

1461
01:12:02,521 --> 01:12:05,070
他自己也不知道怎么去实现更好

1462
01:12:05,071 --> 01:12:07,500
那么就可以提供这种商业支持的服务

1463
01:12:09,510 --> 01:12:11,340
这这是一种隐秘的手段

1464
01:12:11,341 --> 01:12:16,440
第二种手段就是提供像这个同学提到的企业的版本

1465
01:12:16,441 --> 01:12:20,880
我们会在ApiSix上面去做一些功能的增强啊

1466
01:12:22,110 --> 01:12:24,900
或者是企业版的一些功能

1467
01:12:24,901 --> 01:12:27,180
比如说像多租户

1468
01:12:27,181 --> 01:12:28,200
然后用户权限

1469
01:12:28,201 --> 01:12:28,710
管理

1470
01:12:28,711 --> 01:12:29,850
审计日志

1471
01:12:29,851 --> 01:12:31,080
然后等等等等

1472
01:12:31,081 --> 01:12:35,310
这些企业及这些功能把它做成一个开箱即用的企业版本

1473
01:12:35,311 --> 01:12:36,960
这也是一个方向

1474
01:12:36,961 --> 01:12:38,070
对这是第二个

1475
01:12:38,071 --> 01:12:42,420
然后第三个就是我们可以把它做成一个SaaS的服务

1476
01:12:42,421 --> 01:12:44,460
大家可以就像用阿里云

1477
01:12:44,461 --> 01:12:45,480
腾讯云一样的

1478
01:12:45,481 --> 01:12:48,450
然后在云上面点点一个网关就起来了

1479
01:12:48,451 --> 01:12:50,310
再有三种这样的一个服务

1480
01:12:50,311 --> 01:12:50,790
ApiSix呢

1481
01:12:50,791 --> 01:12:52,440
可能现在其实主要在前面两个

1482
01:12:52,441 --> 01:12:59,010
ApiSix有自己的商业支持 有自己的企业版本 对 这其实是有的

1483
01:12:59,011 --> 01:13:01,620
但是我们并没有主主力的去推

1484
01:13:01,621 --> 01:13:03,000
这样的一个企业版本

1485
01:13:03,001 --> 01:13:08,700
因为现在的我们还是希望能够先集中精力把开源项目给做好

1486
01:13:08,701 --> 01:13:10,890
这是其实是一个阶段性的一个考虑

1487
01:13:12,840 --> 01:13:15,360
如何保证这个项目可以长期的维护下去

1488
01:13:15,361 --> 01:13:18,630
这个其实可以分为两个方面来说的

1489
01:13:18,631 --> 01:13:19,320
其实

1490
01:13:19,321 --> 01:13:25,410
作为一个开源项目的一个发起方来说

1491
01:13:25,411 --> 01:13:26,640
ApiSix这个项目呢

1492
01:13:26,641 --> 01:13:31,410
肯定会跟着ApiSix的几个主要的贡献者

1493
01:13:31,411 --> 01:13:34,560
基本上就是我们一辈子的项目对吧

1494
01:13:34,561 --> 01:13:36,870
因为他其实是阿帕奇的顶级项目

1495
01:13:36,871 --> 01:13:41,250
如果你辛辛苦苦把这个项目把他变成了一个顶级项目

1496
01:13:41,251 --> 01:13:42,210
然后过了几年之后

1497
01:13:42,211 --> 01:13:43,860
你又不维护了这个可能性

1498
01:13:43,861 --> 01:13:46,110
基本上没有所以呢

1499
01:13:46,111 --> 01:13:52,080
ApiSix几个主要贡献者肯定会把ApiSix当作自己的,一直会维护的

1500
01:13:52,081 --> 01:13:52,740
这样一个项目

1501
01:13:52,741 --> 01:13:55,320
不管是我们现在的创业公司

1502
01:13:55,321 --> 01:13:57,300
后面是如果失败了

1503
01:13:58,500 --> 01:13:59,280
其实ApiSix

1504
01:13:59,281 --> 01:14:00,210
还是会去

1505
01:14:02,310 --> 01:14:03,210
维护下去

1506
01:14:03,211 --> 01:14:04,470
如果成功了

1507
01:14:04,471 --> 01:14:06,090
那就更不用提了ApiSix

1508
01:14:06,091 --> 01:14:10,350
就会成为公司最重要的这样一个基石的

1509
01:14:10,351 --> 01:14:11,100
这样的一个存在

1510
01:14:13,140 --> 01:14:13,920
然后一天限制

1511
01:14:13,921 --> 01:14:16,470
其实现在已经有自己的商业公司

1512
01:14:16,471 --> 01:14:20,940
而且我们商业公司现在也是一直是处在一个招人的这样一个状态

1513
01:14:20,941 --> 01:14:23,160
我们特别缺Nginx

1514
01:14:23,161 --> 01:14:25,470
OpenResty特别熟的

1515
01:14:25,471 --> 01:14:26,640
这样的一些开发者

1516
01:14:26,641 --> 01:14:30,090
因为这样的开发者其实会比较的稀缺

1517
01:14:30,091 --> 01:14:35,010
所以我们一直是在招聘欢迎有兴趣的同学也可以联系我

1518
01:14:35,011 --> 01:14:36,510
我们一直在招这方面的人

1519
01:14:37,710 --> 01:14:41,220
第12个是ApiSix的CP下发策略

1520
01:14:41,221 --> 01:14:42,510
效率如何

1521
01:14:42,511 --> 01:14:46,170
然后这个效率随DP的节点有没有测试数据

1522
01:14:46,171 --> 01:14:48,930
然后现在这样子的

1523
01:14:48,931 --> 01:14:52,020
ApiSix现在的CP和DP还是在一起的

1524
01:14:52,021 --> 01:14:56,760
我们会在我刚才提到的三点零版本里面做一个完整的剥离

1525
01:14:56,761 --> 01:14:57,240
所以呢

1526
01:14:57,241 --> 01:15:06,090
现在CP和DP之间的效率其实完全取决于ETCD的同步的一个能力

1527
01:15:06,091 --> 01:15:06,780
也就是说

1528
01:15:08,460 --> 01:15:11,490
CP层面把这个数据写到ETCD里面

1529
01:15:11,491 --> 01:15:15,570
那么CP的这个事情就已经做完了那么DP

1530
01:15:16,860 --> 01:15:20,280
从ETCD通过watch接口可以获取到这样一个数据

1531
01:15:20,281 --> 01:15:24,510
如果我的DP和ETCD的网络状态比较好

1532
01:15:24,511 --> 01:15:28,530
那么在一毫秒之内我就可以获取到这样一个数据

1533
01:15:28,531 --> 01:15:30,660
我们做过一些压力的测试

1534
01:15:30,661 --> 01:15:32,790
就是我们会不停的去写

1535
01:15:34,500 --> 01:15:35,250
ETCD

1536
01:15:35,251 --> 01:15:40,620
然后我们的DP都可以非常快地去收到我们CP

1537
01:15:40,621 --> 01:15:42,540
给他下发了一个指令

1538
01:15:42,541 --> 01:15:44,580
对这个还是OK的

1539
01:15:44,581 --> 01:15:46,080
因为在K8S里面

1540
01:15:46,081 --> 01:15:47,070
大家也是这么做的

1541
01:15:47,071 --> 01:15:48,660
比如说在K8S里面

1542
01:15:48,661 --> 01:15:52,920
其实一些配置文件的这样的一些配置了一些数据

1543
01:15:52,921 --> 01:15:56,460
KV的一些数据其实都也是存在ETCD里面的

1544
01:15:56,461 --> 01:15:57,390
所以你K8S里面

1545
01:15:57,391 --> 01:15:59,700
你可以管理非常多的

1546
01:15:59,701 --> 01:16:02,250
大的一个集群也都是OK的

1547
01:16:02,251 --> 01:16:04,290
对其实所以CP、DP之间的效率

1548
01:16:04,291 --> 01:16:06,990
其实现在是取决于ETCD的

1549
01:16:06,991 --> 01:16:11,220
我们把这个锅差不多就甩给ETCD去做这样一个维护

1550
01:16:16,290 --> 01:16:18,150
然后

1551
01:16:19,410 --> 01:16:21,870
13 是否dbless计划

1552
01:16:22,800 --> 01:16:24,540
对比kong， pg换成etcd

1553
01:16:24,541 --> 01:16:26,220
说单点问题可能说服力不太够，因为数据库只影响变更，但运行时服务并不会收到影响

1554
01:16:26,221 --> 01:16:27,990


1555
01:16:27,991 --> 01:16:28,410
嗯

1556
01:16:28,411 --> 01:16:29,670
没错

1557
01:16:29,671 --> 01:16:30,900
确实是这样子的

1558
01:16:30,901 --> 01:16:34,500
就是说对于Kong来说呢

1559
01:16:34,501 --> 01:16:38,400
如果他的因为数据库属于他的CP的层面吧

1560
01:16:38,401 --> 01:16:40,800
就是说如果数据库变化

1561
01:16:40,801 --> 01:16:42,030
如果数据库宕掉的话

1562
01:16:42,031 --> 01:16:44,100
也就只能出他CP挂了

1563
01:16:44,101 --> 01:16:45,720
但是他在DP没有挂

1564
01:16:45,721 --> 01:16:47,430
就是你怎么看这个问题了

1565
01:16:47,431 --> 01:16:48,120
就是你觉得

1566
01:16:48,121 --> 01:16:50,850
如果CP宕掉了不严重

1567
01:16:50,851 --> 01:16:52,440
然后DP能继续工作的话

1568
01:16:52,441 --> 01:16:56,370
让我在这个层面上来说Kong和ApiSix确实是一样的

1569
01:16:56,371 --> 01:16:58,590
但是PG会有另外一个问题

1570
01:16:58,591 --> 01:17:04,140
就是说会给你的开发会造成很多的这种困扰

1571
01:17:04,141 --> 01:17:07,590
比如说我的数据库

1572
01:17:07,591 --> 01:17:11,610
我从DP到CP我去获取这个数据的更新

1573
01:17:11,611 --> 01:17:13,890
我要用轮询的方式去做

1574
01:17:14,970 --> 01:17:17,400
我要去因为PG并没有这种推送

1575
01:17:17,401 --> 01:17:19,440
没有Etcd watch的推送能力

1576
01:17:19,441 --> 01:17:20,910
我要去轮询的去做

1577
01:17:20,911 --> 01:17:23,220
那么这个数据的延时性就会有一个问题

1578
01:17:24,870 --> 01:17:31,560
然后DBLess的计划现在ApiSix有一个DBLess的一个方案

1579
01:17:31,561 --> 01:17:36,300
对你可以在配置文件里面去做一个配置

1580
01:17:36,301 --> 01:17:39,330
对他也可以说我不依赖于一体CD

1581
01:17:39,331 --> 01:17:41,190
我只依赖于本地的一个yaml

1582
01:17:41,191 --> 01:17:44,940
的一个配置文件也可以去控制

1583
01:17:44,941 --> 01:17:45,930
但是呢

1584
01:17:45,931 --> 01:17:46,770
他不太好

1585
01:17:46,771 --> 01:17:49,290
就是他这时候就变成了一个单机的版本了

1586
01:17:49,291 --> 01:17:51,750
因为DBLess其实就是一个单机的版本

1587
01:17:51,751 --> 01:18:04,020
他没有办法去和集群的整个机群去联动这块就没有就是容易做成一个DBLess就变成一个退化成了一个单机的一个版本

1588
01:18:07,680 --> 01:18:09,480
和Kong原理相似

1589
01:18:09,481 --> 01:18:11,310
拆分的想法会走入Istio的坑

1590
01:18:11,311 --> 01:18:11,790


1591
01:18:13,740 --> 01:18:15,270
嗯

1592
01:18:15,271 --> 01:18:16,260
我不太清楚

1593
01:18:16,261 --> 01:18:17,700
Istio的坑是什么

1594
01:18:17,701 --> 01:18:20,970
可以说的更详细点吗

1595
01:18:20,971 --> 01:18:25,860
ApiSix和Kong的原理类似

1596
01:18:25,861 --> 01:18:27,330
其实怎么说呢

1597
01:18:27,331 --> 01:18:31,350
你如果站在一个开发的角度来说呢

1598
01:18:31,351 --> 01:18:33,240
开发语言的角度来说确实是类似的

1599
01:18:33,241 --> 01:18:37,770
因为ApiSix和Kong他都是基于Nginx

1600
01:18:37,771 --> 01:18:41,760
是基于OpenResty去做的一个开发

1601
01:18:41,761 --> 01:18:43,290
所以它的原理是类似的

1602
01:18:43,291 --> 01:18:45,630
而且里面的概念其实也是差不多的

1603
01:18:45,631 --> 01:18:50,460
比如说像router、service、plugin

1604
01:18:50,461 --> 01:18:52,050
这些概念也都是差不多

1605
01:18:52,051 --> 01:18:54,060
其实所有的网关这些概念都是差不多了

1606
01:18:59,070 --> 01:19:02,070
但是我们和Kong其实不太一样的是

1607
01:19:02,071 --> 01:19:09,270
我们在包括整个插件的二次开发的难度以及我们整个运行的效率

1608
01:19:09,271 --> 01:19:11,910
这块其实就差的比较多

1609
01:19:12,990 --> 01:19:19,740
最终用户看到的整体的一个性能延迟以及他好不好部署

1610
01:19:19,741 --> 01:19:21,870
这块差的就会比较多

1611
01:19:21,871 --> 01:19:27,600
并且ApiSix就像我刚才提到了我们会支持这种插件的编排

1612
01:19:27,601 --> 01:19:31,290
其实这块是Kong是做不到的 Kong也意识到了这个问题

1613
01:19:31,291 --> 01:19:33,630
所以他推出了用Golang去写插件

1614
01:19:33,631 --> 01:19:36,690
但是我们更希望大家不写代码

1615
01:19:36,691 --> 01:19:37,680
也可以达到这个效果

1616
01:19:40,290 --> 01:19:41,850
然后Istio每次下发策略

1617
01:19:41,851 --> 01:19:44,070
因为Envoy很多整体策略

1618
01:19:44,071 --> 01:19:45,990
就会进行一个分钟级别

1619
01:19:47,250 --> 01:19:50,130
恩我觉得这对于ApiSix来说应该不会存在这个问题

1620
01:19:50,131 --> 01:19:52,320
因为在我的理解里面

1621
01:19:52,321 --> 01:19:53,760
我们现在的实现里面

1622
01:19:53,761 --> 01:20:00,450
我的DP是通过ETCD 的watch 接口去监听他的变化的

1623
01:20:00,451 --> 01:20:01,380
比如说Istio

1624
01:20:01,381 --> 01:20:07,320
每次下发一条策略就是我的DP层面就监听到这一条变化

1625
01:20:07,321 --> 01:20:10,590
比如说我有一百个ApiSix节点

1626
01:20:10,591 --> 01:20:14,040
那么我就和ETCD建立一百个长连接

1627
01:20:14,041 --> 01:20:17,040
然后在这个长连接里面去监听有没有变化

1628
01:20:18,090 --> 01:20:20,250
所以我因为我对Istio又不是很熟

1629
01:20:20,251 --> 01:20:21,360
我不太确定为什么Istio

1630
01:20:21,361 --> 01:20:23,220
里面下发一个策略

1631
01:20:23,221 --> 01:20:25,710
但Envoy就会进入分钟级了

1632
01:20:25,711 --> 01:20:27,750
他不是增量的吗

1633
01:20:27,751 --> 01:20:29,310
我这块我不是特别确定

1634
01:20:29,311 --> 01:20:31,560
因为我对Istio不是特别熟

1635
01:20:36,120 --> 01:20:40,230
然后watch接口和五秒轮询的差别

1636
01:20:40,231 --> 01:20:44,250
然后配置文件换成共享文件

1637
01:20:45,750 --> 01:20:46,950
OK我这里先说一下

1638
01:20:46,951 --> 01:20:50,820
watch和五秒轮询的一个差别

1639
01:20:50,821 --> 01:20:55,290
watch和5S轮询的差别其实就是一个推和拉的一个差别

1640
01:20:56,940 --> 01:21:06,390
watch是Etcd主动来推给我们的每个网关节点和每一个和每一个网关节点

1641
01:21:06,391 --> 01:21:08,160
和Etcd有个长连接

1642
01:21:08,161 --> 01:21:08,700
然后呢

1643
01:21:08,701 --> 01:21:09,720
发生变化的时候呢

1644
01:21:09,721 --> 01:21:11,430
他就能感知到这个变更

1645
01:21:11,431 --> 01:21:13,230
但是五秒轮询的呢

1646
01:21:13,231 --> 01:21:18,270
他就是一个去数据库里面去自己去查找

1647
01:21:34,170 --> 01:21:34,530
嗯

1648
01:21:34,531 --> 01:21:37,020
然后我先回答一下第14个问题

1649
01:21:37,021 --> 01:21:37,290
第一

1650
01:21:37,291 --> 01:21:38,700
第13个五等

1651
01:21:38,701 --> 01:21:40,650
李辉那边把东西抄完

1652
01:21:42,330 --> 01:21:43,590
现在没错

1653
01:21:43,591 --> 01:21:45,090
确实是有这个问题

1654
01:21:45,091 --> 01:21:45,660
现在呢

1655
01:21:45,661 --> 01:21:48,600
我们是每一个Worker都是单独watch的

1656
01:21:48,601 --> 01:21:51,780
这是一个一直都存在的一个已知的问题

1657
01:21:51,781 --> 01:21:54,660
并不是master的进程进行watch的

1658
01:21:54,661 --> 01:21:56,370
所以确实会有这个问题

1659
01:21:56,371 --> 01:21:59,220
如果是你的CPU核数很多

1660
01:21:59,221 --> 01:22:01,680
然后ApiSix节点数也很多

1661
01:22:01,681 --> 01:22:05,250
那么就会对Etcd的连接数会比较多

1662
01:22:05,251 --> 01:22:07,890
所以就看你的这个数量有多少了

1663
01:22:07,891 --> 01:22:11,700
如果对ETCD的连接数很多可能就会存在性能的问题

1664
01:22:11,701 --> 01:22:14,760
这是一个已知的问题

1665
01:22:14,761 --> 01:22:17,280
这个问题其实是可以解决的

1666
01:22:17,281 --> 01:22:18,360
就是

1667
01:22:18,361 --> 01:22:20,190
其实刚才这个同学你已经提到了

1668
01:22:20,191 --> 01:22:21,210
就是我用Nginx的master进程进行watch

1669
01:22:21,211 --> 01:22:22,950


1670
01:22:22,951 --> 01:22:27,390
watch完之后把这个变更再通知到下面的每一个worker

1671
01:22:27,391 --> 01:22:27,840
但是呢

1672
01:22:27,841 --> 01:22:29,730
由于在Nginx里面呢

1673
01:22:29,731 --> 01:22:31,440
在OpenResty里面、Nginx里面

1674
01:22:31,441 --> 01:22:33,060
他的worker之间是没有很好的直接去通信的

1675
01:22:33,061 --> 01:22:35,190


1676
01:22:35,191 --> 01:22:38,160
所以可能我们需要把这个东西写到一个shareDict

1677
01:22:38,161 --> 01:22:39,660
然后在每个

1678
01:22:39,661 --> 01:22:42,120
worker去监听shareDict的变化

1679
01:22:42,121 --> 01:22:49,320
对其实就等于说加了一层轮询的这样一个逻辑让代码变得稍微复杂一点

1680
01:22:49,321 --> 01:22:51,210
所以这个这个优化

1681
01:22:51,211 --> 01:22:52,140
其实我们还没有做

1682
01:22:53,250 --> 01:22:54,630
第14个

1683
01:22:54,631 --> 01:22:55,890
是一个已知的问题

1684
01:22:55,891 --> 01:22:57,810
现在还没还没有去做对哪个优化

1685
01:23:00,930 --> 01:23:01,950
第13个

1686
01:23:04,950 --> 01:23:06,570
配置文件换成共享文件

1687
01:23:07,560 --> 01:23:08,520
这个是什么意思

1688
01:23:11,730 --> 01:23:15,390
DBLess配置文件换成共享文件

1689
01:23:17,790 --> 01:23:20,340
共享文件是一个什么意思啊

1690
01:23:22,710 --> 01:23:23,040
嗯

1691
01:23:26,220 --> 01:23:27,570
那我明白你的意思了

1692
01:23:27,571 --> 01:23:30,210
我猜我猜测一下

1693
01:23:30,211 --> 01:23:35,670
就说你的意思是说我现在比如说ApiSix支持DBLess

1694
01:23:35,671 --> 01:23:37,140
然后DBLess呢

1695
01:23:37,141 --> 01:23:39,690
他是本地的一个YAML的配置文件

1696
01:23:39,691 --> 01:23:41,070
然后你想把这个YAML

1697
01:23:41,071 --> 01:23:42,720
的配置文件啊明白

1698
01:23:42,721 --> 01:23:46,980
做成一个NAS的一个存储级别的机群

1699
01:23:46,981 --> 01:23:48,690
里面的一个临时共享文件

1700
01:23:51,120 --> 01:23:56,190
额这个我觉得对运维层面可能会难度比较大了

1701
01:23:56,191 --> 01:23:57,600
因为运维起来会比较麻烦

1702
01:23:57,601 --> 01:24:05,250
因为网关之所以大家觉得网关要做到无状态

1703
01:24:05,251 --> 01:24:10,980
其实就是希望这个东西能够随时的新加一个网关

1704
01:24:10,981 --> 01:24:15,600
我只能在LB那一层去做一个加一个IP或者去掉一个就可以了

1705
01:24:15,601 --> 01:24:18,720
如果你说我这个网关服务起来之后

1706
01:24:18,721 --> 01:24:23,310
还要在集群里面去加载一个共享文件夹

1707
01:24:23,311 --> 01:24:24,480
然后里面有个文件

1708
01:24:24,481 --> 01:24:25,020
这样子的话

1709
01:24:25,021 --> 01:24:25,560
我觉得

1710
01:24:26,790 --> 01:24:29,160
可能运维的成本会更高一些

1711
01:24:29,161 --> 01:24:32,610
但我觉得运维的成本会更高一些

1712
01:24:32,611 --> 01:24:36,600
然后我不知道会不会大家都去读写这个文件

1713
01:24:36,601 --> 01:24:38,520
然后会有这样的一些冲突

1714
01:24:38,521 --> 01:24:42,000
我我我个人觉得应该不是一个很好的方法

1715
01:24:42,001 --> 01:24:44,370
因为运维的成本确实会比较高

1716
01:24:45,360 --> 01:24:48,570
我更希望这个东西能够放在一起

1717
01:24:48,571 --> 01:24:50,340
ETCD里面可能会更合适

1718
01:24:50,341 --> 01:24:51,240
再ETCD里面

1719
01:24:51,241 --> 01:24:53,850
其实我们可以做这种版本的控制

1720
01:24:53,851 --> 01:24:55,650
因为ETCD里面有版本的概念

1721
01:24:55,651 --> 01:24:57,090
我们可以做版本控制

1722
01:24:57,091 --> 01:25:02,070
我可以回退到上一个版本或者直接上上上一个版本会有这样一个概念

1723
01:25:02,071 --> 01:25:06,000
但是我如果全部通过配置文件来做的话呢

1724
01:25:06,001 --> 01:25:06,780
其实就

1725
01:25:07,890 --> 01:25:09,570
丧失掉了这样的一些优势

1726
01:25:10,680 --> 01:25:12,630
对我我是这么考虑的

1727
01:25:16,680 --> 01:25:20,130
ApiSix我觉得最好不要用K8S的Etcd

1728
01:25:20,131 --> 01:25:22,770
虽然他可以用因为ApiSix

1729
01:25:22,771 --> 01:25:24,660
现在ETCD里面的目录呢

1730
01:25:24,661 --> 01:25:25,860
是自己的一个目录

1731
01:25:25,861 --> 01:25:29,550
它的前缀是ApiSix的一个前缀

1732
01:25:29,551 --> 01:25:33,090
从原理上来说的是不会有问题的

1733
01:25:33,091 --> 01:25:37,080
但是我觉得和K8S共用一个还是比较危险的

1734
01:25:37,081 --> 01:25:41,760
所以我们在生产上还是建议大家用一套单独的

1735
01:25:42,930 --> 01:25:45,720
ETCD避免的就是大家会互相的影响

1736
01:26:02,880 --> 01:26:07,740
感谢文明老师今天今晚非常精彩的这个分享

1737
01:26:07,741 --> 01:26:09,150
我觉得大家问的都

1738
01:26:10,440 --> 01:26:11,790
我替大家都可以体会到

1739
01:26:13,020 --> 01:26:14,610
都特别有水准啊

1740
01:26:18,870 --> 01:26:22,470
要是讲吃讲是很牛逼

1741
01:26:22,471 --> 01:26:26,670
然后我们的听众也非常非常给力

1742
01:26:26,671 --> 01:26:26,850
哎

1743
01:26:26,851 --> 01:26:28,230
我再补充一下

1744
01:26:28,231 --> 01:26:29,580
我作为外人

1745
01:26:29,581 --> 01:26:31,740
作为一个案发前一篇写个贡献者

1746
01:26:31,741 --> 01:26:33,720
这边确实就是尤其是对比

1747
01:26:34,740 --> 01:26:40,620
我这边其实也少说有两年或者三年的就是空的八年开发经验了

1748
01:26:40,621 --> 01:26:43,710
然后我们这边确实开发一个插件

1749
01:26:43,711 --> 01:26:46,050
是非常非常难受的

1750
01:26:46,051 --> 01:26:50,040
还不如甚至还不如让我去写文件和插件

1751
01:26:51,150 --> 01:26:54,060
就是他这个是写起来非常难受

1752
01:26:54,061 --> 01:26:57,570
我觉得最大差距可能就是代码水平的差距

1753
01:26:59,220 --> 01:27:06,360
或者说就是这种开发者体验这个结果必须为ApiSix代言一下

1754
01:27:06,361 --> 01:27:07,710
就是碰着开发钱

1755
01:27:07,711 --> 01:27:08,940
实在是太差了

1756
01:27:08,941 --> 01:27:11,670
而且性能非常差

1757
01:27:11,671 --> 01:27:14,700
而且其实在离开四十出来之前

1758
01:27:14,701 --> 01:27:19,590
创办了自己的这个代码的代码的问题也非常多

1759
01:27:19,591 --> 01:27:23,970
而且其实带一台四个出来之后同样是花了很大的力气

1760
01:27:23,971 --> 01:27:26,040
实在抄一篇四十的优化

1761
01:27:28,200 --> 01:27:28,800
这个确实

1762
01:27:32,460 --> 01:27:38,550
我看到然后带再次感谢老师的分享

1763
01:27:38,551 --> 01:27:39,390
然后我们

1764
01:27:42,720 --> 01:27:43,200
曾老师

1765
01:27:43,201 --> 01:27:43,860
你有这儿

1766
01:27:43,861 --> 01:27:45,330
你有需要打广告了吗

1767
01:27:45,331 --> 01:27:47,340
或者宣传一下咱们的项目

1768
01:27:49,590 --> 01:27:53,280
其实就是希望大家去省下一篇试一次呗

1769
01:27:53,281 --> 01:27:55,980
就是不一定要加一个四大

1770
01:27:55,981 --> 01:27:58,320
但是其实可以宣传一下

1771
01:27:58,321 --> 01:28:04,110
比如说把今天的后面放出来的一些录播呀啊

1772
01:28:04,111 --> 01:28:07,830
然后我们的一些公众号的一些宣传之类的

1773
01:28:07,831 --> 01:28:08,970
大家可以发朋友圈

1774
01:28:08,971 --> 01:28:09,810
微博之类的

1775
01:28:09,811 --> 01:28:12,150
其实就是一种不会干嘛的

1776
01:28:12,151 --> 01:28:12,810
不可以共享

1777
01:28:12,811 --> 01:28:17,340
觉得就是那个这有没有

1778
01:28:17,341 --> 01:28:19,260
咱们就是一开4G功能

1779
01:28:19,261 --> 01:28:21,420
公众号的二维码有点豆角

1780
01:28:24,120 --> 01:28:25,590
恩现在还没有

1781
01:28:25,591 --> 01:28:29,130
其实大家去关注我们的那个开上不就可以了

1782
01:28:29,131 --> 01:28:30,990
比如说在一片碎石里面

1783
01:28:30,991 --> 01:28:33,780
然后我们有QQ群的那篇献给自己QQ群

1784
01:28:33,781 --> 01:28:35,250
大家可以加到里面去等下

1785
01:28:35,251 --> 01:28:36,840
我应该还能看到我的屏幕是吗

1786
01:28:37,980 --> 01:28:38,880
对还可以的

1787
01:28:42,180 --> 01:28:45,390
哦对其实我们就有一个QQ群

1788
01:28:45,391 --> 01:28:48,930
大家其实是可以去家门QQ群对

1789
01:28:48,931 --> 01:28:50,670
然后还有一个就是我刚才提到的

1790
01:28:50,671 --> 01:28:55,290
我们其实不太看中一个项目的是大树对

1791
01:28:55,291 --> 01:28:57,330
但是我们特别看重的是活跃度

1792
01:28:57,331 --> 01:28:59,580
大家其实也可以去关注下一篇是活跃度

1793
01:28:59,581 --> 01:29:00,240
这是我们的

1794
01:29:01,500 --> 01:29:04,110
比如说我们这是一周的一周了

1795
01:29:04,111 --> 01:29:06,810
其实我们就合并了15个票

1796
01:29:06,811 --> 01:29:08,310
然后关了17个E九

1797
01:29:08,311 --> 01:29:11,550
如果把这个放到一个月的这个范围的话

1798
01:29:11,551 --> 01:29:13,260
他其实就会更多一些

1799
01:29:13,261 --> 01:29:14,130
其实我们算钱

1800
01:29:14,131 --> 01:29:16,110
其实每天都有一两个票

1801
01:29:16,111 --> 01:29:20,250
在被合并对这个还是比较活跃的一个社区

1802
01:29:20,251 --> 01:29:22,320
所以其实大家去选择看一下我们的话

1803
01:29:22,321 --> 01:29:24,690
活跃度其实是一个非常重要的一个指标
